<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ACT 4 Retriburion</title>
  <style>
    :root{
      --bg1:#061220;
      --bg2:#0a2a3d;
      --ice:#cfefff;
      --ice2:#9fd8ff;
      --danger:#ff6b6b;
      --ok:#65ffb2;
      --shadow: rgba(0,0,0,.35);
    }
    *{ box-sizing:border-box; user-select:none; -webkit-tap-highlight-color: transparent; }
    html,body{ height:100%; margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; color: #eaf7ff; }
    body{
      overflow:hidden;
      background:
        radial-gradient(1200px 700px at 30% 20%, rgba(159,216,255,.18), transparent 55%),
        radial-gradient(900px 600px at 80% 10%, rgba(207,239,255,.12), transparent 60%),
        linear-gradient(180deg, var(--bg1), var(--bg2));
    }
    .frost{ position:fixed; inset:-40px; background:
        radial-gradient(800px 400px at 20% 10%, rgba(207,239,255,.10), transparent 60%),
        radial-gradient(700px 380px at 70% 0%, rgba(207,239,255,.08), transparent 60%),
        radial-gradient(900px 500px at 50% 100%, rgba(159,216,255,.08), transparent 65%);
      pointer-events:none;
    }
    #game{ position:fixed; inset:0; }
    canvas{ position:absolute; inset:0; width:100%; height:100%; }

    .hud{
      position:fixed; top:16px; left:16px; right:16px;
      display:flex; align-items:center; justify-content:space-between; gap:12px;
      pointer-events:none;
    }
    .pill{
      pointer-events:none;
      display:flex; align-items:center; gap:10px;
      padding:10px 14px;
      border-radius:999px;
      background: rgba(6,18,32,.45);
      backdrop-filter: blur(10px);
      box-shadow: 0 10px 25px var(--shadow);
      border: 1px solid rgba(207,239,255,.18);
      flex-wrap:wrap;
    }
    .score{ font-weight:700; letter-spacing:.2px; display:flex; align-items:baseline; gap:8px; }
    .score span{ color: var(--ice2); font-size: 22px; }
    .tiny{ opacity:.9; font-size:12px; letter-spacing:.2px; }
    .miss{ opacity:.95; font-size:12px; margin-left:8px; }
    .btnRow{ display:flex; gap:10px; pointer-events:auto; flex-wrap:wrap; justify-content:flex-end; }
    button{
      cursor:pointer;
      border:1px solid rgba(207,239,255,.22);
      color:#eaf7ff;
      background: rgba(6,18,32,.45);
      backdrop-filter: blur(10px);
      padding:10px 12px;
      border-radius:12px;
      box-shadow: 0 10px 25px var(--shadow);
      font-weight:600;
      transition: transform .12s ease, border-color .12s ease, background .12s ease, filter .12s ease, opacity .12s ease;
      white-space:nowrap;
    }
    button:hover{ border-color: rgba(207,239,255,.35); transform: translateY(-1px); }
    button:active{ transform: translateY(0px); }

    .centerOverlay{ position:fixed; inset:0; display:flex; align-items:center; justify-content:center; pointer-events:none; }
    .panel{
      width:min(560px, calc(100% - 32px));
      border-radius:22px;
      background: rgba(6,18,32,.55);
      border: 1px solid rgba(207,239,255,.20);
      box-shadow: 0 18px 60px rgba(0,0,0,.55);
      backdrop-filter: blur(14px);
      padding:18px 18px 14px;
      pointer-events:auto;
      position:relative;
      overflow:hidden;
    }
    .title{ display:flex; align-items:center; justify-content:space-between; gap:12px; margin-bottom:8px; }
    h1{ margin:0; font-size:22px; letter-spacing:.3px; }
    .badge{
      font-size:12px; padding:6px 10px; border-radius:999px;
      border:1px solid rgba(207,239,255,.22);
      background: rgba(207,239,255,.08);
      color: rgba(234,247,255,.95);
      white-space:nowrap;
    }
    .panel p{ margin:10px 0; line-height:1.45; opacity:.95; }
    .panel .big{ font-size:18px; font-weight:800; margin-top:4px; margin-bottom:10px; }
    .panel .actions{ display:flex; gap:10px; flex-wrap:wrap; margin-top:12px; }
    .panel .actions button{ border-radius:14px; padding:12px 14px; }
    .primary{ border-color: rgba(101,255,178,.35) !important; background: rgba(101,255,178,.12) !important; }
    .danger{ border-color: rgba(255,107,107,.35) !important; background: rgba(255,107,107,.10) !important; }
    .hidden{ display:none !important; }

    .footerHint{
      position:fixed; bottom:12px; left:0; right:0;
      text-align:center; font-size:12px; opacity:.7; pointer-events:none;
    }
    .grid{ display:grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap:12px; margin-top:12px; }
    @media (max-width: 520px){ .grid{ grid-template-columns: 1fr; } }
    .cardBtn{
      position:relative;
      text-align:left;
      padding:14px 14px 12px;
      border-radius:18px;
      border:1px solid rgba(207,239,255,.20);
      background: rgba(6,18,32,.38);
      box-shadow: 0 14px 40px rgba(0,0,0,.35);
      overflow:hidden;
    }
    .cardBtn .topline{ display:flex; align-items:flex-start; justify-content:space-between; gap:10px; margin-bottom:8px; }
    .cardBtn .name{
      font-weight:800; letter-spacing:.2px; flex:1 1 auto; min-width:0; line-height:1.15;
      display:-webkit-box; -webkit-line-clamp:2; -webkit-box-orient:vertical;
      overflow:hidden; text-overflow:ellipsis; word-break: break-word;
    }
    .cardBtn .sub{ font-size:12px; opacity:.85; }
    .chip{
      font-size:12px; padding:6px 10px; border-radius:999px;
      border:1px solid rgba(207,239,255,.18);
      background: rgba(207,239,255,.06);
      opacity:.95; white-space:nowrap; flex:0 0 auto;
      max-width:42%; overflow:hidden; text-overflow:ellipsis;
      transition: opacity .12s ease, transform .12s ease;
    }
    @media (max-width: 420px){ .cardBtn{ padding:12px 12px 10px; } .chip{ max-width:46%; } }
    .cardBtn[disabled]{ cursor:not-allowed; filter: grayscale(.3); opacity:.85; }
    .cardBtn:hover{ border-color: rgba(207,239,255,.34); }

    .mine.easy::before{
      content:""; position:absolute; inset:-80px;
      background:
        radial-gradient(480px 240px at 20% 20%, rgba(101,255,178,.25), transparent 60%),
        radial-gradient(520px 280px at 80% 10%, rgba(159,216,255,.18), transparent 65%),
        radial-gradient(560px 320px at 50% 110%, rgba(101,255,178,.12), transparent 70%);
      opacity:0; transform: scale(1.02);
      transition: opacity .18s ease, transform .18s ease; pointer-events:none;
    }
    .mine.easy:hover::before{ opacity:1; transform: scale(1.0); }
    .mine.easy::after{
      content:"–õ–ï–ì–ö–û"; position:absolute; top:12px; right:12px;
      font-size:11px; letter-spacing:.9px; padding:6px 10px; border-radius:999px;
      border:1px solid rgba(101,255,178,.30);
      background: rgba(101,255,178,.10);
      color: rgba(223,255,240,.95);
      opacity:0; transition: opacity .18s ease; pointer-events:none;
    }
    .mine.easy:hover::after{ opacity:1; }
    .mine.easy:hover .chip{ opacity:0; transform: translateY(-2px) scale(.98); pointer-events:none; }

    .panel.forest{
      background:
        radial-gradient(600px 280px at 10% 10%, rgba(124, 255, 178, .10), transparent 60%),
        radial-gradient(520px 280px at 90% 0%, rgba(255, 214, 120, .10), transparent 62%),
        linear-gradient(180deg, rgba(10,32,18,.70), rgba(6,18,32,.55));
      border-color: rgba(150, 255, 196, .18);
    }
    .panel.forest .badge{ border-color: rgba(150,255,196,.22); background: rgba(150,255,196,.08); }
    .forestBtn{
      border-color: rgba(150,255,196,.22);
      background:
        radial-gradient(420px 180px at 20% 0%, rgba(150,255,196,.10), transparent 62%),
        radial-gradient(420px 180px at 90% 10%, rgba(255,214,120,.10), transparent 62%),
        rgba(6,18,32,.30);
    }
    .forestBtn:hover{ border-color: rgba(150,255,196,.35); }

    .panel.forge{
      background:
        radial-gradient(640px 320px at 15% 10%, rgba(255, 165, 72, .14), transparent 60%),
        radial-gradient(560px 280px at 90% 0%, rgba(255, 214, 120, .10), transparent 62%),
        linear-gradient(180deg, rgba(32,18,10,.72), rgba(6,18,32,.55));
      border-color: rgba(255, 195, 140, .18);
    }
    .panel.forge .badge{ border-color: rgba(255,195,140,.22); background: rgba(255,195,140,.08); }
    .forgeBtn{
      border-color: rgba(255,195,140,.22);
      background:
        radial-gradient(520px 220px at 25% 0%, rgba(255,195,140,.12), transparent 62%),
        radial-gradient(520px 220px at 90% 10%, rgba(255,214,120,.10), transparent 62%),
        rgba(6,18,32,.30);
    }
    .forgeBtn:hover{ border-color: rgba(255,195,140,.35); }

    .herbBtn{
      border-color: rgba(159,216,255,.22);
      background:
        radial-gradient(520px 220px at 25% 0%, rgba(120,190,255,.14), transparent 62%),
        radial-gradient(520px 220px at 90% 10%, rgba(120,220,255,.10), transparent 62%),
        rgba(6,18,32,.30);
    }
    .herbBtn:hover{ border-color: rgba(159,216,255,.35); }

    .fireHerbBtn{
      border-color: rgba(255,195,140,.22);
      background:
        radial-gradient(520px 220px at 25% 0%, rgba(255,165,72,.16), transparent 62%),
        radial-gradient(520px 220px at 90% 10%, rgba(255,214,120,.12), transparent 62%),
        rgba(6,18,32,.30);
    }
    .fireHerbBtn:hover{ border-color: rgba(255,195,140,.35); }

    .inputRow{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; margin-top:10px; }
    input{
      flex:1 1 180px;
      border-radius:14px;
      border:1px solid rgba(207,239,255,.22);
      background: rgba(6,18,32,.35);
      color:#eaf7ff;
      padding:12px 12px;
      outline:none;
      box-shadow: 0 10px 25px var(--shadow);
      backdrop-filter: blur(10px);
      font-weight:700; letter-spacing:.8px;
    }
    .toast{
      margin-top:10px; font-size:12px; opacity:.88;
      padding:10px 12px; border-radius:14px;
      border:1px solid rgba(255,107,107,.25);
      background: rgba(255,107,107,.08);
      display:none;
    }
    .toast.show{ display:block; }
  </style>
</head>
<body>
  <div class="frost"></div>

  <div id="game">
    <canvas id="bg"></canvas>
    <canvas id="fx"></canvas>
  </div>

  <div class="hud">
    <div class="pill">
      <div class="score">–°—á—ë—Ç: <span id="score">0</span></div>
      <div class="miss" id="misses">–ü—Ä–æ–º–∞—Ö–∏: 0/5</div>
      <div class="tiny" id="diff">–°–ª–æ–∂–Ω–æ—Å—Ç—å: 1.00√ó</div>
    </div>
    <div class="btnRow">
      <button id="pauseBtn" title="P">–ü–∞—É–∑–∞</button>
      <button id="restartBtn" title="R">–†–µ—Å—Ç–∞—Ä—Ç</button>
      <button id="musicBtn" title="–ú—É–∑—ã–∫–∞ on/off">–ú—É–∑—ã–∫–∞: ON</button>
      <button id="sfxBtn" title="–ó–≤—É–∫ on/off">–ó–≤—É–∫: ON</button>
    </div>
  </div>

  <div class="centerOverlay" id="overlay">
    <div class="panel" id="mainPanel">
      <div class="title">
        <h1>ACT 4 Retriburion</h1>
        <div class="badge">—Ä–∞–±–æ—Ç–∞</div>
      </div>
      <p class="big">–ù–∞ –∫–∞–∫—É—é —Ä–∞–±–æ—Ç—É –ø–æ–π–¥—ë–º —Å–µ–≥–æ–¥–Ω—è?</p>
      <p class="tiny">–í—ã–±–∏—Ä–∞–π –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ ‚Äî –¥–∞–ª—å—à–µ –æ—Ç–∫—Ä–æ–µ—Ç—Å—è —Å–ø–∏—Å–æ–∫ –ª–æ–∫–∞—Ü–∏–π.</p>
      <div class="grid">
        <button class="cardBtn" id="goMines">
          <div class="topline"><div class="name">–®–∞—Ö—Ç—ã</div></div>
          <div class="sub">–ö–∞–º–Ω–∏, —Å–∫–æ—Ä–æ—Å—Ç—å, —Ä–µ–∞–∫—Ü–∏—è. –õ—ë–¥ –∏ —Ö—Ä—É—Å—Ç.</div>
        </button>
        <button class="cardBtn forestBtn" id="goForest">
          <div class="topline"><div class="name">–õ–µ—Å–æ–ø–∏–ª–∫–∞</div></div>
          <div class="sub">–î–µ—Ä–µ–≤–æ, —Ç–æ–ø–æ—Ä –∏ –±—ã—Å—Ç—Ä—ã–µ —É–¥–∞—Ä—ã A/D.</div>
        </button>
        <button class="cardBtn forgeBtn" id="goForge">
          <div class="topline"><div class="name">–ö—É–∑–Ω–∏—Ü–∞</div><div class="chip">–ø–∞—Ä–æ–ª—å</div></div>
          <div class="sub">–î–æ—Å—Ç—É–ø –ø–æ –∫–æ–¥—É. –ö–æ–≤–∫–∞ –∏ –∏—Å–ø—ã—Ç–∞–Ω–∏—è.</div>
        </button>
        <button class="cardBtn herbBtn" id="goHerbs">
          <div class="topline"><div class="name">–°–±–æ—Ä —Ç—Ä–∞–≤</div><div class="chip">2 —Ä–µ–∂–∏–º–∞</div></div>
          <div class="sub">–ú–æ—Ä–æ–∑–Ω–∞—è —Ç—Ä–∞–≤–∞ + –æ–≥–Ω–µ–Ω–Ω—ã–π –∫—É—Å—Ç —Å —è–≥–æ–¥–∞–º–∏.</div>
        </button>
      </div>
      <div class="actions">
        <button id="howBtn">–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ</button>
      </div>
    </div>

    <div class="panel hidden" id="minesPanel">
      <div class="title">
        <h1>ACT 4 Retriburion</h1>
        <div class="badge">—à–∞—Ö—Ç—ã</div>
      </div>
      <p class="big">–í –∫–∞–∫—É—é —à–∞—Ö—Ç—É –ø–æ–π–¥–µ–º —Å–µ–≥–æ–¥–Ω—è?</p>
      <p class="tiny">—É—Ç–æ—á–Ω–∏ —É –î–∞–Ω–∏ –≤ –∫–∞–∫—É—é –º–æ–∂–Ω–æ –∏–¥—Ç–∏.</p>
      <div class="grid">
        <button class="cardBtn mine easy" id="mine1">
          <div class="topline">
            <div class="name">–õ–µ–¥—è–Ω—ã–µ —à–∞—Ö—Ç—ã –Ω–æ—Ä—Ç–ª–µ–Ω–¥–∞</div>
            <div class="chip">–¥–æ—Å—Ç—É–ø–Ω–æ</div>
          </div>
          <div class="sub">–ö–ª–∏–∫–∞–π –ø–æ –∫–∞–º–Ω—è–º –¥–æ —Ç–æ–≥–æ, –∫–∞–∫ –æ–Ω–∏ –∏—Å—á–µ–∑–Ω—É—Ç.</div>
        </button>
        <button class="cardBtn mine" id="mine2">
          <div class="topline"><div class="name">–®–∞—Ö—Ç–∞ 2</div><div class="chip">–ì–ª—É–±–æ–∫–∏–µ —à–∞—Ö—Ç—ã –Ω–æ—Ä—Ç–ª–µ–Ω–¥–∞</div></div>
          <div class="sub">–û—Ö –∑—Ä—è –≤—ã —Å—é–¥–∞ –ª–µ–∑–µ—Ç–µ</div>
        </button>
        <button class="cardBtn mine" id="mine3" disabled>
          <div class="topline"><div class="name">–®–∞—Ö—Ç–∞ 3</div><div class="chip">üîí —Å–∫–æ—Ä–æ</div></div>
          <div class="sub">–ü–æ–∫–∞ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–æ.</div>
        </button>
        <button class="cardBtn mine" id="mine4" disabled>
          <div class="topline"><div class="name">–®–∞—Ö—Ç–∞ 4</div><div class="chip">üîí —Å–∫–æ—Ä–æ</div></div>
          <div class="sub">–ü–æ–∫–∞ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–æ.</div>
        </button>
        <button class="cardBtn mine" id="mine5" disabled>
          <div class="topline"><div class="name">–®–∞—Ö—Ç–∞ 5</div><div class="chip">üîí —Å–∫–æ—Ä–æ</div></div>
          <div class="sub">–ü–æ–∫–∞ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–æ.</div>
        </button>
      </div>
      <div class="toast" id="toastMines">–≠—Ç–æ—Ç —É—Ä–æ–≤–µ–Ω—å –ø–æ–∫–∞ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω ‚ùÑÔ∏è</div>
      <div class="actions">
        <button id="backToMainFromMines">–ù–∞–∑–∞–¥</button>
      </div>
    </div>

    <div class="panel forest hidden" id="forestPanel">
      <div class="title">
        <h1>ACT 4 Retriburion</h1>
        <div class="badge">–ª–µ—Å–æ–ø–∏–ª–∫–∞</div>
      </div>
      <p class="big">–ì–¥–µ –±—É–¥–µ–º —Ä—É–±–∏—Ç—å –ª–µ—Å?</p>
      <p class="tiny">–£—Ç–æ—á–Ω–∏ —É –î–∞–Ω–∏ –∫—É–¥–∞ –º–æ–∂–Ω–æ –∏–¥—Ç–∏.</p>
      <div class="grid">
        <button class="cardBtn forestBtn" id="forest1">
          <div class="topline">
            <div class="name">–õ–µ—Å–æ–ø–∏–ª–∫–∞ –ù–æ—Ä—Ç–ª–µ–Ω–¥–∞</div>
            <div class="chip">–¥–æ—Å—Ç—É–ø–Ω–æ</div>
          </div>
          <div class="sub">–¢–æ–ø–æ—Ä —Å–ª–µ–≤–∞/—Å–ø—Ä–∞–≤–∞ ‚Äî –∂–º–∏ A –∏–ª–∏ D –≤–æ–≤—Ä–µ–º—è.</div>
        </button>
        <button class="cardBtn forestBtn" id="forest2" disabled>
          <div class="topline"><div class="name">–õ–µ—Å 2</div><div class="chip">üîí —Å–∫–æ—Ä–æ</div></div>
          <div class="sub">–ü–æ–∫–∞ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–æ.</div>
        </button>
        <button class="cardBtn forestBtn" id="forest3" disabled>
          <div class="topline"><div class="name">–õ–µ—Å 3</div><div class="chip">üîí —Å–∫–æ—Ä–æ</div></div>
          <div class="sub">–ü–æ–∫–∞ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–æ.</div>
        </button>
      </div>
      <div class="toast" id="toastForest">–≠—Ç–æ—Ç –º–∞—Ä—à—Ä—É—Ç –ø–æ–∫–∞ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω üå≤</div>
      <div class="actions">
        <button id="backToMainFromForest">–ù–∞–∑–∞–¥</button>
      </div>
    </div>

    <div class="panel forge hidden" id="forgePassPanel">
      <div class="title">
        <h1>–ö—É–∑–Ω–∏—Ü–∞</h1>
        <div class="badge">–¥–æ—Å—Ç—É–ø</div>
      </div>
      <p class="big">–í–≤–µ–¥–∏—Ç–µ –ø–∞—Ä–æ–ª—å</p>
      <p class="tiny">–ë–µ–∑ –∫–æ–¥–∞ –∫—É–∑–Ω—è –∑–∞–∫—Ä—ã—Ç–∞.</p>
      <div class="inputRow">
        <input id="forgePass" type="password" inputmode="numeric" placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢" maxlength="8" />
        <button class="primary" id="forgeEnterBtn">–í–æ–π—Ç–∏</button>
      </div>
      <div class="toast" id="toastForgePass">–ù–µ–≤–µ—Ä–Ω—ã–π –ø–∞—Ä–æ–ª—å üî•</div>
      <div class="actions">
        <button id="backToMainFromForgePass">–ù–∞–∑–∞–¥</button>
      </div>
    </div>

    <div class="panel forge hidden" id="forgeMenuPanel">
      <div class="title">
        <h1>–ö—É–∑–Ω–∏—Ü–∞</h1>
        <div class="badge">—Ä–µ–∂–∏–º—ã</div>
      </div>
      <p class="big">–ß—Ç–æ –±—É–¥–µ–º –¥–µ–ª–∞—Ç—å?</p>
      <p class="tiny">–í—ã–±–µ—Ä–∏ —Ä–µ–∂–∏–º –∫–æ–≤–∫–∏.</p>
      <div class="grid">
        <button class="cardBtn forgeBtn" id="forgeBasic">
          <div class="topline">
            <div class="name">–ö–æ–≤–∞—Ç—å –±–∞–∑–æ–≤–æ–µ –æ—Ä—É–∂–∏–µ</div>
            <div class="chip">–æ—Ç–∫—Ä—ã—Ç–æ</div>
          </div>
          <div class="sub">–†—É–¥–∞ ‚Üí 3 —Å–µ–∫ ‚Üí QTE (–∏–Ω–æ–≥–¥–∞ D D) ‚Üí –í–µ–Ω—Ç–∏–ª—è—Ç–æ—Ä.</div>
        </button>
        <button class="cardBtn forgeBtn" disabled>
          <div class="topline"><div class="name">–ö–æ–≤–∫–∞ 2</div><div class="chip">üîí —Å–∫–æ—Ä–æ</div></div>
          <div class="sub">–ü–æ–∫–∞ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–æ.</div>
        </button>
      </div>
      <div class="actions">
        <button id="backToMainFromForgeMenu">–ù–∞–∑–∞–¥</button>
      </div>
    </div>

    <div class="panel hidden" id="herbsMenuPanel">
      <div class="title">
        <h1>–°–±–æ—Ä —Ç—Ä–∞–≤</h1>
        <div class="badge">—Ä–µ–∂–∏–º—ã</div>
      </div>
      <p class="big">–ß—Ç–æ —Å–æ–±–∏—Ä–∞–µ–º?</p>
      <p class="tiny">–í—ã–±–µ—Ä–∏ —Ä–µ–∂–∏–º.</p>
      <div class="grid">
        <button class="cardBtn herbBtn" id="herbMode1">
          <div class="topline"><div class="name">–ú–æ—Ä–æ–∑–Ω–∞—è —Ç—Ä–∞–≤–∞</div><div class="chip">–¥–æ—Å—Ç—É–ø–Ω–æ</div></div>
          <div class="sub">–†–µ–∂—å –∫–∞–∫ Fruit Ninja + –∂–º–∏ –ø—Ä–æ–±–µ–ª –æ—Ç —Å–Ω–µ–≥–∞.</div>
        </button>
        <button class="cardBtn fireHerbBtn" id="herbMode2">
          <div class="topline"><div class="name">–û–≥–Ω–µ–Ω–Ω—ã–π –∫—É—Å—Ç</div><div class="chip">–¥–æ—Å—Ç—É–ø–Ω–æ</div></div>
          <div class="sub">–ö–ª–∏–∫–∞–π —è–≥–æ–¥—ã ‚Üí –æ–Ω–∏ –ø–∞–¥–∞—é—Ç ‚Üí –ª–æ–≤–∏ –∫–æ—Ä–∑–∏–Ω–æ–π. –° –∫–∞–∂–¥—ã–º —Ä–∞—É–Ω–¥–æ–º —è–≥–æ–¥ –±–æ–ª—å—à–µ.</div>
        </button>
      </div>
      <div class="actions">
        <button id="backToMainFromHerbsMenu">–ù–∞–∑–∞–¥</button>
      </div>
    </div>

    <div class="panel hidden" id="howPanel">
      <div class="title">
        <h1>–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ</h1>
        <div class="badge">–ø–æ–¥—Å–∫–∞–∑–∫–∞</div>
      </div>
      <p><b>–®–∞—Ö—Ç—ã:</b> üñ±Ô∏è –∫–ª–∏–∫–∞–π –ø–æ –∫–∞–º–Ω—è–º. 5 –ø—Ä–æ–º–∞—Ö–æ–≤ –ø–æ–¥—Ä—è–¥ ‚Äî –ø–æ—Ä–∞–∂–µ–Ω–∏–µ.</p>
      <p><b>–õ–µ—Å–æ–ø–∏–ª–∫–∞:</b> ‚å®Ô∏è –∂–º–∏ <b>A</b> (—É–¥–∞—Ä —Å–ª–µ–≤–∞) –∏–ª–∏ <b>D</b> (—É–¥–∞—Ä —Å–ø—Ä–∞–≤–∞) ‚Äî –ø–æ–∫–∞ –µ—Å—Ç—å –≤—Ä–µ–º—è.</p>
      <p><b>–ö—É–∑–Ω–∏—Ü–∞:</b> üñ±Ô∏è –ø–µ—Ä–µ—Ç–∞—â–∏ —Ä—É–¥—É ‚Üí ‚å®Ô∏è W/A/S/D (–∏–Ω–æ–≥–¥–∞ <b>D D</b>) ‚Üí üåÄ –≤–µ–Ω—Ç–∏–ª—è—Ç–æ—Ä 15 –æ–±–æ—Ä–æ—Ç–æ–≤ –∑–∞ 3—Å. –ò–Ω–æ–≥–¥–∞ –ø–æ—è–≤–ª—è–µ—Ç—Å—è –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä –≤ –¥—Ä—É–≥–æ–º –º–µ—Å—Ç–µ ‚Äî –∂–º–∏ <b>–ü—Ä–æ–±–µ–ª</b> –±—ã—Å—Ç—Ä–æ.</p>
      <p><b>–°–±–æ—Ä —Ç—Ä–∞–≤ ‚Äî –º–æ—Ä–æ–∑–Ω–∞—è:</b> üñ±Ô∏è –∑–∞–∂–º–∏ –∏ <b>–ø—Ä–æ–≤–µ–¥–∏</b> –ø–æ —Ç—Ä–∞–≤–µ —á—Ç–æ–±—ã —Å—Ä–µ–∑–∞—Ç—å. –î–æ–ª–≥–æ –¥–µ—Ä–∂–∞—Ç—å –∑–∞–∂–∞—Ç—ã–º ‚Äî –ø–æ—Ä–∞–∂–µ–Ω–∏–µ. ‚å®Ô∏è –ñ–º–∏ <b>–ü—Ä–æ–±–µ–ª</b>, –∏–Ω–∞—á–µ –∑–∞ 3 —Å–µ–∫—É–Ω–¥—ã —ç–∫—Ä–∞–Ω –ø–æ–±–µ–ª–µ–µ—Ç ‚Üí –ø–æ—Ä–∞–∂–µ–Ω–∏–µ.</p>
      <p><b>–°–±–æ—Ä —Ç—Ä–∞–≤ ‚Äî –æ–≥–Ω–µ–Ω–Ω—ã–π –∫—É—Å—Ç:</b> üñ±Ô∏è –∫–ª–∏–∫–∞–π –ø–æ —è–≥–æ–¥–∞–º –Ω–∞ –∫—É—Å—Ç–µ ‚Äî –æ–Ω–∏ –ø–∞–¥–∞—é—Ç. üß∫ –ü–µ—Ä–µ–¥–≤–∏–≥–∞–π –∫–æ—Ä–∑–∏–Ω—É –º—ã—à–∫–æ–π/–ø–∞–ª—å—Ü–µ–º (–∏–ª–∏ A/D) –∏ –ª–æ–≤–∏. –ï—Å–ª–∏ —è–≥–æ–¥–∞ —É–ø–∞–ª–∞ –º–∏–º–æ ‚Äî –ø–æ—Ä–∞–∂–µ–Ω–∏–µ. –í—Ä–µ–º—è —Ä–∞—É–Ω–¥–∞ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–æ.</p>
      <p>‚å®Ô∏è <b>P</b> ‚Äî –ø–∞—É–∑–∞, <b>R</b> ‚Äî —Ä–µ—Å—Ç–∞—Ä—Ç, <b>Esc</b> ‚Äî –≤ –º–µ–Ω—é.</p>
      <div class="actions">
        <button class="primary" id="backBtn">–ù–∞–∑–∞–¥</button>
      </div>
    </div>

    <div class="panel hidden" id="losePanel">
      <div class="title">
        <h1>–ü–æ—Ä–∞–∂–µ–Ω–∏–µ ‚ùÑÔ∏è</h1>
        <div class="badge" id="finalBadge">—Å—á—ë—Ç: 0</div>
      </div>
      <p class="big" id="loseReason">‚Äî</p>
      <p class="tiny" id="jobLine"></p>
      <p class="tiny" id="locLine"></p>
      <p id="statsLine" class="tiny"></p>
      <div class="actions">
        <button class="primary" id="againBtn">–ï—â—ë —Ä–∞–∑</button>
        <button class="danger" id="toMenuBtn">–í –º–µ–Ω—é</button>
      </div>
    </div>

    <div class="panel hidden" id="pausePanel">
      <div class="title">
        <h1>–ü–∞—É–∑–∞</h1>
        <div class="badge">–Ω–∞–∂–º–∏ P</div>
      </div>
      <p>–û—Ç–¥–æ—Ö–Ω–∏ —Å–µ–∫—É–Ω–¥–æ—á–∫—É üôÇ</p>
      <div class="actions">
        <button class="primary" id="resumeBtn">–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å</button>
        <button class="danger" id="pauseRestartBtn">–†–µ—Å—Ç–∞—Ä—Ç</button>
      </div>
    </div>
  </div>

  <div class="footerHint" id="footerHint">–í—ã–±–µ—Ä–∏ —Ä–∞–±–æ—Ç—É: —à–∞—Ö—Ç—ã, –ª–µ—Å–æ–ø–∏–ª–∫–∞, –∫—É–∑–Ω–∏—Ü–∞ –∏–ª–∏ —Å–±–æ—Ä —Ç—Ä–∞–≤.</div>

  <script>
    (() => {
      const bg = document.getElementById('bg');
      const fx = document.getElementById('fx');
      const bctx = bg.getContext('2d');
      const fctx = fx.getContext('2d');

      const scoreEl = document.getElementById('score');
      const diffEl = document.getElementById('diff');
      const missesEl = document.getElementById('misses');
      const footerHint = document.getElementById('footerHint');

      const overlay = document.getElementById('overlay');
      const mainPanel = document.getElementById('mainPanel');
      const minesPanel = document.getElementById('minesPanel');
      const forestPanel = document.getElementById('forestPanel');
      const howPanel = document.getElementById('howPanel');
      const losePanel = document.getElementById('losePanel');
      const pausePanel = document.getElementById('pausePanel');
      const forgePassPanel = document.getElementById('forgePassPanel');
      const forgeMenuPanel = document.getElementById('forgeMenuPanel');
      const herbsMenuPanel = document.getElementById('herbsMenuPanel');

      const goMines = document.getElementById('goMines');
      const goForest = document.getElementById('goForest');
      const goForge = document.getElementById('goForge');
      const goHerbs = document.getElementById('goHerbs');

      const backToMainFromMines = document.getElementById('backToMainFromMines');
      const backToMainFromForest = document.getElementById('backToMainFromForest');
      const backToMainFromForgePass = document.getElementById('backToMainFromForgePass');
      const backToMainFromForgeMenu = document.getElementById('backToMainFromForgeMenu');
      const backToMainFromHerbsMenu = document.getElementById('backToMainFromHerbsMenu');

      const howBtn = document.getElementById('howBtn');
      const backBtn = document.getElementById('backBtn');

      const mine1 = document.getElementById('mine1');
      const mine2 = document.getElementById('mine2');
      const mine3 = document.getElementById('mine3');
      const mine4 = document.getElementById('mine4');
      const mine5 = document.getElementById('mine5');

      const forest1 = document.getElementById('forest1');
      const forest2 = document.getElementById('forest2');
      const forest3 = document.getElementById('forest3');

      const toastMines = document.getElementById('toastMines');
      const toastForest = document.getElementById('toastForest');

      const forgePass = document.getElementById('forgePass');
      const forgeEnterBtn = document.getElementById('forgeEnterBtn');
      const toastForgePass = document.getElementById('toastForgePass');
      const forgeBasic = document.getElementById('forgeBasic');

      const herbMode1Btn = document.getElementById('herbMode1');
      const herbMode2Btn = document.getElementById('herbMode2');

      const loseReasonEl = document.getElementById('loseReason');
      const finalBadge = document.getElementById('finalBadge');
      const statsLine = document.getElementById('statsLine');
      const jobLine = document.getElementById('jobLine');
      const locLine = document.getElementById('locLine');

      const againBtn = document.getElementById('againBtn');
      const toMenuBtn = document.getElementById('toMenuBtn');

      const pauseBtn = document.getElementById('pauseBtn');
      const restartBtn = document.getElementById('restartBtn');
      const resumeBtn = document.getElementById('resumeBtn');
      const pauseRestartBtn = document.getElementById('pauseRestartBtn');

      const musicBtn = document.getElementById('musicBtn');
      const sfxBtn = document.getElementById('sfxBtn');

      const DPR = () => Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      let W = 0, H = 0, dpr = DPR();

      const rand = (a,b)=> Math.random()*(b-a)+a;
      const clamp01 = (v)=> Math.max(0, Math.min(1, v));
      const easeIn = (t)=> t*t;
      const easeOut = (t)=> 1 - (1-t)*(1-t);
      const easeInOut = (t)=> t<0.5 ? 2*t*t : 1 - Math.pow(-2*t+2,2)/2;

      function roundRectPath(ctx, x, y, w, h, r){
        r = Math.max(0, Math.min(r, Math.min(w,h)/2));
        ctx.beginPath();
        ctx.moveTo(x+r, y);
        ctx.lineTo(x+w-r, y);
        ctx.quadraticCurveTo(x+w, y, x+w, y+r);
        ctx.lineTo(x+w, y+h-r);
        ctx.quadraticCurveTo(x+w, y+h, x+w-r, y+h);
        ctx.lineTo(x+r, y+h);
        ctx.quadraticCurveTo(x, y+h, x, y+h-r);
        ctx.lineTo(x, y+r);
        ctx.quadraticCurveTo(x, y, x+r, y);
        ctx.closePath();
      }

      function showToast(el, msg){
        el.textContent = msg;
        el.classList.add('show');
        clearTimeout(el._t);
        el._t = setTimeout(()=> el.classList.remove('show'), 1400);
      }

      // ===== AUDIO =====
      let audioCtx = null;
      let master = null;
      let musicGain = null;
      let sfxGain = null;
      let musicOn = true;
      let sfxOn = true;
      let musicTimer = null;

      function ensureAudio(){
        if (audioCtx) return;
        const AC = window.AudioContext || window.webkitAudioContext;
        audioCtx = new AC();
        master = audioCtx.createGain(); master.gain.value = 0.55;
        musicGain = audioCtx.createGain(); musicGain.gain.value = 0.18;
        sfxGain = audioCtx.createGain(); sfxGain.gain.value = 0.85;
        musicGain.connect(master);
        sfxGain.connect(master);
        master.connect(audioCtx.destination);
      }
      async function resumeAudio(){
        ensureAudio();
        if (audioCtx.state !== 'running') { try { await audioCtx.resume(); } catch {} }
      }
      function clickNoise(duration=0.03){
        const buffer = audioCtx.createBuffer(1, Math.floor(audioCtx.sampleRate * duration), audioCtx.sampleRate);
        const data = buffer.getChannelData(0);
        for(let i=0;i<data.length;i++) data[i] = (Math.random()*2-1) * (1 - i/data.length);
        const src = audioCtx.createBufferSource();
        src.buffer = buffer;
        return src;
      }
      function playRockHit(intensity=1){
        if(!sfxOn) return; ensureAudio();
        const t = audioCtx.currentTime;
        const n = clickNoise(0.06);
        const bp = audioCtx.createBiquadFilter(); bp.type='bandpass'; bp.frequency.setValueAtTime(1800 + 700*intensity, t); bp.Q.setValueAtTime(9, t);
        const hp = audioCtx.createBiquadFilter(); hp.type='highpass'; hp.frequency.setValueAtTime(900, t);
        const g = audioCtx.createGain();
        g.gain.setValueAtTime(0.0001, t);
        g.gain.exponentialRampToValueAtTime(0.55*intensity, t+0.008);
        g.gain.exponentialRampToValueAtTime(0.0001, t+0.10);
        n.connect(bp); bp.connect(hp); hp.connect(g); g.connect(sfxGain);
        n.start(t); n.stop(t+0.12);
      }
      function playWoodHit(intensity=1){
        if(!sfxOn) return; ensureAudio();
        const t = audioCtx.currentTime;
        const osc = audioCtx.createOscillator(); osc.type='sine';
        osc.frequency.setValueAtTime(140 + 40*intensity, t);
        osc.frequency.exponentialRampToValueAtTime(70, t+0.08);
        const og = audioCtx.createGain();
        og.gain.setValueAtTime(0.0001, t);
        og.gain.exponentialRampToValueAtTime(0.55*intensity, t+0.006);
        og.gain.exponentialRampToValueAtTime(0.0001, t+0.12);
        const n = clickNoise(0.04);
        const lp = audioCtx.createBiquadFilter(); lp.type='lowpass'; lp.frequency.setValueAtTime(1200 + 300*intensity, t); lp.Q.setValueAtTime(0.8, t);
        const ng = audioCtx.createGain();
        ng.gain.setValueAtTime(0.0001, t);
        ng.gain.exponentialRampToValueAtTime(0.25*intensity, t+0.005);
        ng.gain.exponentialRampToValueAtTime(0.0001, t+0.08);
        osc.connect(og); og.connect(sfxGain);
        n.connect(lp); lp.connect(ng); ng.connect(sfxGain);
        osc.start(t); osc.stop(t+0.14);
        n.start(t); n.stop(t+0.10);
      }
      function playAnvilHit(intensity=1){
        if(!sfxOn) return; ensureAudio();
        const t = audioCtx.currentTime;
        const o1 = audioCtx.createOscillator();
        const o2 = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        const bp = audioCtx.createBiquadFilter();
        o1.type='square'; o2.type='triangle';
        o1.frequency.setValueAtTime(420 + 120*intensity, t);
        o2.frequency.setValueAtTime(840 + 220*intensity, t);
        bp.type='bandpass'; bp.frequency.setValueAtTime(1500 + 500*intensity, t); bp.Q.setValueAtTime(8, t);
        g.gain.setValueAtTime(0.0001, t);
        g.gain.exponentialRampToValueAtTime(0.55*intensity, t+0.005);
        g.gain.exponentialRampToValueAtTime(0.0001, t+0.18);
        o1.connect(bp); o2.connect(bp); bp.connect(g); g.connect(sfxGain);
        o1.start(t); o2.start(t);
        o1.stop(t+0.20); o2.stop(t+0.20);
        const n = clickNoise(0.03);
        const hp = audioCtx.createBiquadFilter(); hp.type='highpass'; hp.frequency.setValueAtTime(2600, t);
        const ng = audioCtx.createGain();
        ng.gain.setValueAtTime(0.0001, t);
        ng.gain.exponentialRampToValueAtTime(0.20*intensity, t+0.004);
        ng.gain.exponentialRampToValueAtTime(0.0001, t+0.08);
        n.connect(hp); hp.connect(ng); ng.connect(sfxGain);
        n.start(t); n.stop(t+0.09);
      }
      function playHerbSlice(intensity=1){
        if(!sfxOn) return; ensureAudio();
        const t = audioCtx.currentTime;
        const n = clickNoise(0.04);
        const hp = audioCtx.createBiquadFilter(); hp.type='highpass'; hp.frequency.setValueAtTime(1200 + 500*intensity, t);
        const g = audioCtx.createGain();
        g.gain.setValueAtTime(0.0001, t);
        g.gain.exponentialRampToValueAtTime(0.35*intensity, t+0.006);
        g.gain.exponentialRampToValueAtTime(0.0001, t+0.08);
        n.connect(hp); hp.connect(g); g.connect(sfxGain);
        n.start(t); n.stop(t+0.09);

        const o = audioCtx.createOscillator(); o.type='sine';
        o.frequency.setValueAtTime(980, t);
        o.frequency.exponentialRampToValueAtTime(520, t+0.06);
        const og = audioCtx.createGain();
        og.gain.setValueAtTime(0.0001,t);
        og.gain.exponentialRampToValueAtTime(0.18*intensity,t+0.01);
        og.gain.exponentialRampToValueAtTime(0.0001,t+0.08);
        o.connect(og); og.connect(sfxGain);
        o.start(t); o.stop(t+0.09);
      }
      function playFirePop(intensity=1){
        if(!sfxOn) return; ensureAudio();
        const t = audioCtx.currentTime;
        const o = audioCtx.createOscillator(); o.type='square';
        o.frequency.setValueAtTime(520 + 220*intensity, t);
        o.frequency.exponentialRampToValueAtTime(220, t+0.06);
        const g = audioCtx.createGain();
        g.gain.setValueAtTime(0.0001,t);
        g.gain.exponentialRampToValueAtTime(0.20*intensity,t+0.004);
        g.gain.exponentialRampToValueAtTime(0.0001,t+0.08);
        o.connect(g); g.connect(sfxGain);
        o.start(t); o.stop(t+0.09);

        const n = clickNoise(0.02);
        const bp = audioCtx.createBiquadFilter(); bp.type='bandpass';
        bp.frequency.setValueAtTime(1800, t); bp.Q.setValueAtTime(10, t);
        const ng = audioCtx.createGain();
        ng.gain.setValueAtTime(0.0001,t);
        ng.gain.exponentialRampToValueAtTime(0.12*intensity,t+0.004);
        ng.gain.exponentialRampToValueAtTime(0.0001,t+0.06);
        n.connect(bp); bp.connect(ng); ng.connect(sfxGain);
        n.start(t); n.stop(t+0.07);
      }

      function stopMusic(){ if(musicTimer){ clearInterval(musicTimer); musicTimer = null; } }
      function playSynthNote(freq, dur=0.08, vol=0.08){
        const t = audioCtx.currentTime;
        const o = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        const lp = audioCtx.createBiquadFilter();
        const isHerb = (mode==='herbs' || mode==='herbs_fire');
        o.type = (mode==='forest') ? 'triangle' : (mode==='forge' ? 'square' : 'sine');
        if(isHerb) o.type='sine';
        o.frequency.setValueAtTime(freq, t);
        lp.type='lowpass';
        lp.frequency.setValueAtTime((mode==='forest') ? 2200 : (mode==='forge' ? 1400 : 1700), t);
        if(isHerb) lp.frequency.setValueAtTime(2400, t);
        g.gain.setValueAtTime(0.0001, t);
        g.gain.exponentialRampToValueAtTime(vol, t+0.01);
        g.gain.exponentialRampToValueAtTime(0.0001, t+dur);
        o.connect(lp); lp.connect(g); g.connect(musicGain);
        o.start(t); o.stop(t+dur+0.02);
      }
      function playPerc(dur=0.03){
        const t = audioCtx.currentTime;
        const n = clickNoise(dur);
        const bp = audioCtx.createBiquadFilter();
        bp.type='bandpass';
        bp.frequency.setValueAtTime((mode==='forest') ? 900 : (mode==='forge' ? 1100 : 1400), t);
        if(mode==='herbs' || mode==='herbs_fire') bp.frequency.setValueAtTime(1600, t);
        bp.Q.setValueAtTime(6, t);
        const g = audioCtx.createGain();
        g.gain.setValueAtTime(0.0001, t);
        g.gain.exponentialRampToValueAtTime(0.06, t+0.004);
        g.gain.exponentialRampToValueAtTime(0.0001, t+dur);
        n.connect(bp); bp.connect(g); g.connect(musicGain);
        n.start(t); n.stop(t+dur+0.01);
      }
      function startMusic(){
        if(!musicOn) return;
        ensureAudio();
        stopMusic();
        const isHerb = (mode==='herbs' || mode==='herbs_fire');
        const bpmBase = (mode==='forge') ? 92 : 84;
        let bpm = Math.min(160, bpmBase + difficulty*9);
        if(isHerb) bpm = Math.min(170, 96 + difficulty*10);
        const stepMs = 60000 / bpm / 2;
        musicTimer = setInterval(()=>{
          if(!musicOn || !audioCtx || audioCtx.state !== 'running') return;
          const scale = (mode==='forest') ? [0,2,4,7,9]
                       : (mode==='forge') ? [0,3,5,6,10]
                       : isHerb ? [0,2,5,7,9,12]
                       : [0,3,5,7,10];
          const root = (mode==='forest') ? 220 : (mode==='herbs_fire' ? 246 : 196);
          const step = (Date.now() / stepMs) | 0;
          if(step % 4 === 0) playSynthNote(root/2, 0.10, 0.10);
          const density = clamp01((difficulty-1)/6);
          if(Math.random() < 0.35 + density*0.45){
            const deg = scale[(Math.random()*scale.length)|0];
            const octave = (Math.random() < 0.7) ? 1 : 2;
            const freq = root * Math.pow(2, octave) * Math.pow(2, deg/12);
            playSynthNote(freq, 0.06, 0.08);
          }
          if(Math.random() < 0.18 + density*0.25) playPerc(0.035);
        }, stepMs);
      }

      function resize(){
        dpr = DPR();
        W = Math.floor(window.innerWidth);
        H = Math.floor(window.innerHeight);
        for (const c of [bg, fx]) {
          c.width = Math.floor(W * dpr);
          c.height = Math.floor(H * dpr);
          c.style.width = W + 'px';
          c.style.height = H + 'px';
        }
        bctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        fctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        initSnow();
        initLeaves();
        initEmbers();
      }
      window.addEventListener('resize', resize, { passive:true });

      // --- Snowflakes ---
      const flakes = [];
      const FLAKES = 140;
      function initSnow(){
        flakes.length = 0;
        for(let i=0;i<FLAKES;i++){
          flakes.push({
            x: rand(0,W), y: rand(0,H),
            r: rand(0.8,2.4),
            vx: rand(-0.25,0.25),
            vy: rand(0.6,1.6),
            wob: rand(0,Math.PI*2),
            wobSpd: rand(0.006,0.018),
            a: rand(0.25,0.85)
          });
        }
      }

      // --- Embers (for herbs_fire) ---
      const embers = [];
      const EMBERS = 120;
      function initEmbers(){
        embers.length = 0;
        for(let i=0;i<EMBERS;i++){
          embers.push({
            x: rand(0,W),
            y: rand(0,H),
            r: rand(0.7,2.2),
            vx: rand(-0.18,0.18),
            vy: rand(0.55,1.45),
            a: rand(0.20,0.75),
            heat: rand(0.0,1.0),
            wob: rand(0,Math.PI*2),
            wobSpd: rand(0.008,0.022)
          });
        }
      }

      function drawBackgroundBase(){
        bctx.clearRect(0,0,W,H);

        const baseCol = (mode==='forest')
          ? 'rgba(150,255,196,0.14)'
          : (mode==='forge')
            ? 'rgba(255,195,140,0.16)'
            : (mode==='herbs_fire')
              ? 'rgba(255,145,70,0.18)'
              : (mode==='herbs')
                ? 'rgba(120,190,255,0.18)'
                : 'rgba(159,216,255,0.18)';

        const g = bctx.createRadialGradient(W*0.35, H*0.15, 10, W*0.35, H*0.15, Math.max(W,H)*0.8);
        g.addColorStop(0, baseCol);
        g.addColorStop(1, 'rgba(0,0,0,0)');
        bctx.fillStyle = g;
        bctx.fillRect(0,0,W,H);

        if(mode==='forge'){
          bctx.fillStyle='rgba(0,0,0,0.20)';
          for(let i=0;i<42;i++){
            bctx.beginPath();
            bctx.arc(rand(0,W), rand(0,H), rand(0.6,1.7), 0, Math.PI*2);
            bctx.fill();
          }
          return;
        }

        if(mode==='herbs_fire'){
          const h = bctx.createRadialGradient(W*0.62, H*0.78, 10, W*0.62, H*0.78, Math.max(W,H)*0.9);
          h.addColorStop(0,'rgba(255,120,60,0.18)');
          h.addColorStop(1,'rgba(0,0,0,0)');
          bctx.fillStyle=h; bctx.fillRect(0,0,W,H);

          for(const e of embers){
            e.wob += e.wobSpd;
            e.x += e.vx + Math.sin(e.wob)*0.25;
            e.y -= e.vy;
            if (e.y < -20) { e.y = H + 20; e.x = rand(0, W); e.heat = rand(0,1); }
            if (e.x < -10) e.x = W + 10;
            if (e.x > W + 10) e.x = -10;

            const t = e.heat;
            const col = `rgba(${Math.round(255)},${Math.round(160 + 60*t)},${Math.round(70 + 40*t)},${e.a})`;
            bctx.beginPath();
            bctx.arc(e.x, e.y, e.r*(1 + Math.sin(e.wob)*0.12), 0, Math.PI*2);
            bctx.fillStyle = col;
            bctx.fill();
          }
          return;
        }

        for(const f of flakes){
          f.wob += f.wobSpd;
          f.x += f.vx + Math.sin(f.wob)*0.25;
          f.y += f.vy;
          if (f.y > H + 10) { f.y = -10; f.x = rand(0, W); }
          if (f.x < -10) f.x = W + 10;
          if (f.x > W + 10) f.x = -10;
          bctx.beginPath();
          bctx.arc(f.x, f.y, f.r, 0, Math.PI*2);
          bctx.fillStyle = `rgba(207,239,255,${f.a})`;
          bctx.fill();
        }
      }

      // Leaves (forest)
      const leaves = [];
      const LEAVES = 55;
      function initLeaves(){
        leaves.length = 0;
        for(let i=0;i<LEAVES;i++){
          leaves.push({
            x: rand(0,W),
            y: rand(-H, H),
            s: rand(0.65,1.25),
            vx: rand(-0.25,0.25),
            vy: rand(0.35,0.95),
            rot: rand(0,Math.PI*2),
            rotSpd: rand(-0.02,0.02),
            wob: rand(0,Math.PI*2),
            wobSpd: rand(0.008,0.02),
            alpha: rand(0.35,0.85),
            hue: rand(85,130),
            hue2: rand(35,70)
          });
        }
      }
      function drawLeaves(){
        for(const L of leaves){
          L.wob += L.wobSpd;
          L.rot += L.rotSpd;
          L.x += L.vx + Math.sin(L.wob)*0.35;
          L.y += L.vy;

          if (L.y > H + 40) { L.y = rand(-120,-20); L.x = rand(0,W); }
          if (L.x < -60) L.x = W + 60;
          if (L.x > W + 60) L.x = -60;

          const w = 10*L.s, h = 16*L.s;

          fctx.save();
          fctx.translate(L.x, L.y);
          fctx.rotate(L.rot);

          const g = fctx.createLinearGradient(-w, -h, w, h);
          g.addColorStop(0, `hsla(${L.hue},70%,55%,${0.85*L.alpha})`);
          g.addColorStop(1, `hsla(${L.hue2},80%,55%,${0.65*L.alpha})`);

          fctx.fillStyle = g;
          fctx.beginPath();
          fctx.moveTo(0, -h);
          fctx.quadraticCurveTo(w, -h*0.2, w*0.6, h*0.75);
          fctx.quadraticCurveTo(0, h, -w*0.6, h*0.75);
          fctx.quadraticCurveTo(-w, -h*0.2, 0, -h);
          fctx.closePath();
          fctx.fill();

          fctx.strokeStyle = `rgba(255,255,255,${0.10*L.alpha})`;
          fctx.lineWidth = 1;
          fctx.beginPath();
          fctx.moveTo(0, -h*0.85);
          fctx.lineTo(0, h*0.85);
          fctx.stroke();

          fctx.restore();
        }
      }

      // ---------- Game state ----------
      let running=false, paused=false, lost=false;
      let mode='mines'; // mines | forest | forge | herbs | herbs_fire

      let score=0, difficulty=1;
      let lastTime = performance.now();

      const MAX_MISSES=5;
      let missesStreak=0;

      let currentJobName='‚Äî';
      let currentLocationName='‚Äî';

      let spawned=0, smashed=0;
      let particles=[];

      function updateMissesUI(){
        missesEl.textContent = `–ü—Ä–æ–º–∞—Ö–∏: ${missesStreak}/${MAX_MISSES}`;
        missesEl.style.color = (missesStreak>=3) ? 'rgba(255,107,107,.95)' : 'rgba(234,247,255,.95)';
      }

      function computeDifficulty(){
        difficulty = 1 + Math.pow(score/12, 1.15);
        diffEl.textContent = `–°–ª–æ–∂–Ω–æ—Å—Ç—å: ${difficulty.toFixed(2)}√ó`;
      }

      function hideAllPanels(){
        mainPanel.classList.add('hidden');
        minesPanel.classList.add('hidden');
        forestPanel.classList.add('hidden');
        howPanel.classList.add('hidden');
        losePanel.classList.add('hidden');
        pausePanel.classList.add('hidden');
        forgePassPanel.classList.add('hidden');
        forgeMenuPanel.classList.add('hidden');
        herbsMenuPanel.classList.add('hidden');
      }

      function showMainMenu(){
        running=false; paused=false; lost=false;
        hideAllPanels();
        overlay.classList.remove('hidden');
        mainPanel.classList.remove('hidden');
        footerHint.textContent = '–í—ã–±–µ—Ä–∏ —Ä–∞–±–æ—Ç—É: —à–∞—Ö—Ç—ã, –ª–µ—Å–æ–ø–∏–ª–∫–∞, –∫—É–∑–Ω–∏—Ü–∞ –∏–ª–∏ —Å–±–æ—Ä —Ç—Ä–∞–≤.';
      }

      function showMinesMenu(){
        running=false; paused=false; lost=false;
        hideAllPanels();
        overlay.classList.remove('hidden');
        minesPanel.classList.remove('hidden');
        footerHint.textContent = '–ü–æ–¥—Å–∫–∞–∑–∫–∞: –ø—Ä–æ–º–∞—Ö–∏ –ø–æ–¥—Ä—è–¥ —É–±–∏–≤–∞—é—Ç ‚Äî –∫–ª–∏–∫–∞–π —Ç–æ—á–Ω–µ–µ ‚ùÑÔ∏è';
      }

      function showForestMenu(){
        running=false; paused=false; lost=false;
        hideAllPanels();
        overlay.classList.remove('hidden');
        forestPanel.classList.remove('hidden');
        footerHint.textContent = '–ü–æ–¥—Å–∫–∞–∑–∫–∞: —Å–ª–µ–≤–∞ A, —Å–ø—Ä–∞–≤–∞ D ‚Äî –±–µ–π –±—ã—Å—Ç—Ä–æ üå≤';
      }

      function showForgePass(){
        running=false; paused=false; lost=false;
        hideAllPanels();
        overlay.classList.remove('hidden');
        forgePassPanel.classList.remove('hidden');
        footerHint.textContent = '–ö—É–∑–Ω–∏—Ü–∞: –¥–æ—Å—Ç—É–ø –ø–æ –ø–∞—Ä–æ–ª—é.';
        forgePass.value = '';
        setTimeout(()=> forgePass.focus(), 80);
      }

      function showForgeMenu(){
        running=false; paused=false; lost=false;
        hideAllPanels();
        overlay.classList.remove('hidden');
        forgeMenuPanel.classList.remove('hidden');
        footerHint.textContent = '–ö—É–∑–Ω–∏—Ü–∞: –≤—ã–±–µ—Ä–∏ —Ä–µ–∂–∏–º.';
      }

      function showHerbsMenu(){
        running=false; paused=false; lost=false;
        hideAllPanels();
        overlay.classList.remove('hidden');
        herbsMenuPanel.classList.remove('hidden');
        footerHint.textContent = '–°–±–æ—Ä —Ç—Ä–∞–≤: –≤—ã–±–µ—Ä–∏ —Ä–µ–∂–∏–º.';
      }

      function togglePause(force){
        if (!running && !paused) return;
        paused = (typeof force === 'boolean') ? force : !paused;

        if (paused){
          hideAllPanels();
          overlay.classList.remove('hidden');
          pausePanel.classList.remove('hidden');
        } else {
          hideAllPanels();
          overlay.classList.add('hidden');
        }
      }

      function lose(reason){
        running=false; paused=false; lost=true;

        if (reason==='miss_clicks') loseReasonEl.textContent = '–°–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ –ø—Ä–æ–º–∞—Ö–æ–≤.';
        else if (reason==='miss_rock') loseReasonEl.textContent = '–ö–∞–º–µ–Ω—å –∏—Å—á–µ–∑ —Ä–∞–Ω—å—à–µ, —á–µ–º —Ç—ã –µ–≥–æ —Å–ª–æ–º–∞–ª.';
        else if (reason==='wood_timeout') loseReasonEl.textContent = '–ù–µ —É—Å–ø–µ–ª —É–¥–∞—Ä–∏—Ç—å –≤–æ–≤—Ä–µ–º—è.';
        else if (reason==='wood_wrong') loseReasonEl.textContent = '–ù–µ–≤–µ—Ä–Ω—ã–π —É–¥–∞—Ä. –ù—É–∂–Ω–æ –±—ã–ª–æ —Å –¥—Ä—É–≥–æ–π —Å—Ç–æ—Ä–æ–Ω—ã.';
        else if (reason==='forge_wrong_slot') loseReasonEl.textContent = '–†—É–¥—É –ø–æ–ª–æ–∂–∏–ª –Ω–µ —Ç—É–¥–∞.';
        else if (reason==='forge_timeout') loseReasonEl.textContent = '–ù–µ —É–ª–æ–∂–∏–ª—Å—è –ø–æ –≤—Ä–µ–º–µ–Ω–∏.';
        else if (reason==='forge_wrong_key') loseReasonEl.textContent = '–ù–∞–∂–∞–ª –Ω–µ —Ç—É –∫–Ω–æ–ø–∫—É.';
        else if (reason==='forge_fan_fail') loseReasonEl.textContent = '–ù–µ —É—Å–ø–µ–ª –ø–æ–π–º–∞—Ç—å/–ø—Ä–æ–∫—Ä—É—Ç–∏—Ç—å –≤–µ–Ω—Ç–∏–ª—è—Ç–æ—Ä.';
        else if (reason==='forge_space_missed') loseReasonEl.textContent = '–ù–µ —É—Å–ø–µ–ª –Ω–∞–∂–∞—Ç—å –ü–†–û–ë–ï–õ –ø–æ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä—É!';
        else if (reason==='herb_hold') loseReasonEl.textContent = '–°–ª–∏—à–∫–æ–º –¥–æ–ª–≥–æ –¥–µ—Ä–∂–∞–ª –∑–∞–∂–∞—Ç–æ–π –∫–Ω–æ–ø–∫—É.';
        else if (reason==='herb_missed') loseReasonEl.textContent = '–¢—Ä–∞–≤–∞ —É—à–ª–∞ ‚Äî –Ω–µ —É—Å–ø–µ–ª —Å—Ä–µ–∑–∞—Ç—å.';
        else if (reason==='snowed') loseReasonEl.textContent = '–¢–µ–±—è –∑–∞–Ω–µ—Å–ª–æ —Å–Ω–µ–≥–æ–º. –ù—É–∂–Ω–æ –±—ã–ª–æ –∂–∞—Ç—å –ø—Ä–æ–±–µ–ª!';
        else if (reason==='fire_missed') loseReasonEl.textContent = '–Ø–≥–æ–¥–∞ —É–ø–∞–ª–∞ –º–∏–º–æ –∫–æ—Ä–∑–∏–Ω—ã.';
        else if (reason==='fire_timeout') loseReasonEl.textContent = '–ù–µ —É—Å–ø–µ–ª —Å–æ–±—Ä–∞—Ç—å —è–≥–æ–¥—ã –≤–æ–≤—Ä–µ–º—è.';
        else loseReasonEl.textContent = '–ü–æ—Ä–∞–∂–µ–Ω–∏–µ.';

        jobLine.textContent = `–†–∞–±–æ—Ç–∞: ${currentJobName}`;
        locLine.textContent = `–õ–æ–∫–∞—Ü–∏—è: ${currentLocationName}`;
        finalBadge.textContent = `—Å—á—ë—Ç: ${score}`;

        const acc = spawned ? Math.round((smashed/spawned)*100) : 0;
        if(mode==='mines'){
          statsLine.textContent = `–ö–∞–º–Ω–µ–π: ${spawned}, —Å–ª–æ–º–∞–Ω–æ: ${smashed} (${acc}%).`;
        } else if(mode==='forest'){
          statsLine.textContent = `–£–¥–∞—Ä–æ–≤: ${smashed}, —Ç–µ–º–ø: ${difficulty.toFixed(2)}√ó`;
        } else if(mode==='forge'){
          statsLine.textContent = `–£—Å–ø–µ—à–Ω—ã—Ö —Ä—É–¥: ${smashed}, —Ç–µ–º–ø: ${difficulty.toFixed(2)}√ó`;
        } else if(mode==='herbs'){
          statsLine.textContent = `–¢—Ä–∞–≤: ${spawned}, —Å—Ä–µ–∑–∞–Ω–æ: ${smashed} (${acc}%).`;
        } else {
          statsLine.textContent = `–Ø–≥–æ–¥ –ø–æ–π–º–∞–Ω–æ: ${smashed}, —Ä–∞—É–Ω–¥–æ–≤: ${fireRoundNumber}`;
        }

        hideAllPanels();
        overlay.classList.remove('hidden');
        losePanel.classList.remove('hidden');
      }

      function resetCommon(){
        running=true; paused=false; lost=false;
        score=0; difficulty=1;
        missesStreak=0;
        updateMissesUI();

        spawned=0; smashed=0;
        particles=[];

        scoreEl.textContent = score;
        computeDifficulty();

        hideAllPanels();
        overlay.classList.add('hidden');

        if (musicOn && audioCtx && audioCtx.state === 'running') startMusic();
      }

      // ---------- Mines ----------
      let rocks=[];
      let spawnTimer=0;
      let nextSpawn=900;

      function scheduleNextSpawn(){
        const base=950, min=260;
        const interval = Math.max(min, base/(0.85 + difficulty*0.75));
        nextSpawn = interval + rand(-60, 90);
      }
      function rockLifetime(){
        const base=1050, min=360;
        const life = Math.max(min, base/(0.85 + difficulty*0.9));
        return life + rand(-40, 70);
      }
      function spawnRock(){
        const size = rand(36,64)*(0.98 + Math.min(0.35, score/80));
        const x = rand(size, W-size);
        const y = rand(size+60, H-size-30);
        rocks.push({
          x,y,r:size/2,
          born: performance.now(),
          life: rockLifetime(),
          wob: rand(0,Math.PI*2),
          wobSpd: rand(0.006,0.02),
          crack:0
        });
        spawned++;
      }
      function drawRock(r, now){
        const age = now - r.born;
        const k = Math.min(1, age/r.life);
        const alpha = 1 - Math.max(0,(k-0.85)/0.15)*0.75;
        const danger = k>0.78;

        r.wob += r.wobSpd;
        r.crack = Math.min(1, age/r.life);

        const rr = r.r*(1 + Math.sin(r.wob)*0.02);

        const points=11, ang0=r.wob;
        fctx.beginPath();
        for(let i=0;i<=points;i++){
          const a = ang0 + (i/points)*Math.PI*2;
          const wob = 0.14*Math.sin(a*3 + ang0*4) + 0.08*Math.cos(a*5 - ang0*3);
          const rad = rr*(1+wob);
          const px = r.x + Math.cos(a)*rad;
          const py = r.y + Math.sin(a)*rad;
          if(i===0) fctx.moveTo(px,py); else fctx.lineTo(px,py);
        }
        fctx.closePath();

        fctx.save();
        fctx.shadowColor='rgba(0,0,0,0.35)';
        fctx.shadowBlur=18;
        fctx.shadowOffsetY=10;
        fctx.fillStyle=`rgba(6,18,32,${0.22*alpha})`;
        fctx.fill();
        fctx.restore();

        const grad = fctx.createRadialGradient(r.x-rr*0.25, r.y-rr*0.35, rr*0.2, r.x, r.y, rr*1.2);
        grad.addColorStop(0, `rgba(207,239,255,${0.95*alpha})`);
        grad.addColorStop(0.55, `rgba(159,216,255,${0.55*alpha})`);
        grad.addColorStop(1, `rgba(20,70,100,${0.45*alpha})`);
        fctx.fillStyle=grad;
        fctx.fill();

        fctx.lineWidth=2;
        fctx.strokeStyle=`rgba(207,239,255,${0.35*alpha})`;
        fctx.stroke();

        if(r.crack>0){
          fctx.beginPath();
          const len = rr*(0.4 + r.crack*0.8);
          const a = ang0 + now*0.002;
          fctx.moveTo(r.x - Math.cos(a)*len*0.2, r.y - Math.sin(a)*len*0.2);
          fctx.lineTo(r.x + Math.cos(a)*len, r.y + Math.sin(a)*len);
          fctx.lineWidth=1.5;
          fctx.strokeStyle=`rgba(234,247,255,${0.55*alpha})`;
          fctx.stroke();
        }

        const start = -Math.PI/2;
        fctx.beginPath();
        fctx.arc(r.x, r.y, rr*0.72, start, start + Math.PI*2*(1-k));
        fctx.lineWidth=3;
        fctx.strokeStyle = danger ? 'rgba(255,107,107,0.75)' : 'rgba(101,255,178,0.6)';
        fctx.stroke();

        if(danger){
          fctx.beginPath();
          fctx.arc(r.x, r.y, rr*1.06, 0, Math.PI*2);
          fctx.lineWidth=2;
          fctx.strokeStyle=`rgba(255,107,107,${0.55*alpha})`;
          fctx.stroke();
        }
        return k;
      }
      function hitRock(x,y){
        for(let i=rocks.length-1;i>=0;i--){
          const r=rocks[i];
          const dx=x-r.x, dy=y-r.y;
          if(dx*dx+dy*dy <= r.r*r.r){
            smashRock(i);
            return true;
          }
        }
        return false;
      }
      function burstIce(x,y,rad){
        const n = Math.floor(18 + rad*0.5);
        for(let i=0;i<n;i++){
          const a=rand(0,Math.PI*2), sp=rand(0.8,4.2);
          particles.push({x,y,vx:Math.cos(a)*sp, vy:Math.sin(a)*sp, r:rand(1.2,3.4), life:rand(380,720), born:performance.now(), kind:'ice'});
        }
        particles.push({ring:true,x,y,r:Math.max(10,rad*0.55), life:260, born:performance.now(), kind:'ice'});
      }
      function smashRock(i){
        const r=rocks[i];
        smashed++;
        score++;
        scoreEl.textContent = score;
        computeDifficulty();
        if (audioCtx && audioCtx.state === 'running') playRockHit(Math.min(1.6, 1 + difficulty*0.12));
        missesStreak=0;
        updateMissesUI();
        burstIce(r.x,r.y,r.r);
        rocks.splice(i,1);
        scheduleNextSpawn();
        if (musicOn && audioCtx && audioCtx.state === 'running') startMusic();
      }

      // ---------- Forest ----------
      let swingStart=0;
      let swingLife=900;
      let swingSide='left';
      let swingResolved=false;

      function forestUpdateTiming(){
        const base=950, min=280;
        swingLife = Math.max(min, base/(0.85 + difficulty*0.85));
      }
      function forestNextSwing(now){
        swingStart=now;
        swingSide = (Math.random()<0.5) ? 'left' : 'right';
        swingResolved=false;
      }
      function burstWood(x,y,rad){
        const n = Math.floor(18 + rad*0.45);
        for(let i=0;i<n;i++){
          const a=rand(-Math.PI*0.15, Math.PI*1.15), sp=rand(1.0,4.8);
          particles.push({x,y,vx:Math.cos(a)*sp, vy:Math.sin(a)*sp - rand(1.0,2.3), r:rand(1.4,3.3), life:rand(340,740), born:performance.now(), kind:'wood'});
        }
        particles.push({ring:true,x,y,r:Math.max(10,rad*0.6), life:240, born:performance.now(), kind:'wood'});
      }
      function forestResolveCorrect(now){
        swingResolved=true;
        smashed++;
        score++;
        scoreEl.textContent = score;
        computeDifficulty();
        if (audioCtx && audioCtx.state === 'running') playWoodHit(Math.min(1.6, 1 + difficulty*0.10));
        forestUpdateTiming();
        burstWood(W*0.5, H*0.64, 28);
        forestNextSwing(now+20);
        if (musicOn && audioCtx && audioCtx.state === 'running') startMusic();
      }

      function drawForestBackLayer(){
        const g1 = fctx.createRadialGradient(W*0.18, H*0.18, 10, W*0.18, H*0.18, Math.max(W,H)*0.9);
        g1.addColorStop(0,'rgba(150,255,196,0.14)');
        g1.addColorStop(1,'rgba(0,0,0,0)');
        fctx.fillStyle=g1; fctx.fillRect(0,0,W,H);

        const g2 = fctx.createRadialGradient(W*0.85, H*0.12, 10, W*0.85, H*0.12, Math.max(W,H)*0.8);
        g2.addColorStop(0,'rgba(255,214,120,0.10)');
        g2.addColorStop(1,'rgba(0,0,0,0)');
        fctx.fillStyle=g2; fctx.fillRect(0,0,W,H);

        const v = fctx.createRadialGradient(W*0.5,H*0.5,Math.min(W,H)*0.35, W*0.5,H*0.5,Math.max(W,H)*0.75);
        v.addColorStop(0,'rgba(0,0,0,0)');
        v.addColorStop(1,'rgba(0,0,0,0.26)');
        fctx.fillStyle=v; fctx.fillRect(0,0,W,H);

        const soil = fctx.createLinearGradient(0,H*0.62,0,H);
        soil.addColorStop(0,'rgba(10,32,18,0.00)');
        soil.addColorStop(0.55,'rgba(10,32,18,0.22)');
        soil.addColorStop(1,'rgba(10,32,18,0.36)');
        fctx.fillStyle=soil; fctx.fillRect(0,0,W,H);
      }

      function drawForestTree(now){
        const cx=W*0.5;
        const baseY=H*0.80;
        const trunkTopY=H*0.44;

        const trunkW = Math.min(98, Math.max(66, W*0.105));
        const trunkX = cx - trunkW*0.45;
        const trunkH = baseY - trunkTopY;

        fctx.save();
        fctx.shadowColor='rgba(0,0,0,0.45)';
        fctx.shadowBlur=20;
        fctx.shadowOffsetY=12;

        const trunkGrad = fctx.createLinearGradient(trunkX, trunkTopY, trunkX+trunkW, baseY);
        trunkGrad.addColorStop(0,'rgba(105,72,42,0.95)');
        trunkGrad.addColorStop(0.45,'rgba(160,112,70,0.93)');
        trunkGrad.addColorStop(1,'rgba(82,54,34,0.95)');
        fctx.fillStyle=trunkGrad;

        roundRectPath(fctx, trunkX, trunkTopY, trunkW*0.90, trunkH, 26);
        fctx.fill();
        fctx.restore();

        const crownY = H*0.29;
        const crownR = Math.min(182, Math.max(130, W*0.19));
        const wob = Math.sin(now*0.0012)*1.8;

        function blob(x,y,r,a){
          const g = fctx.createRadialGradient(x-r*0.2,y-r*0.2,10,x,y,r*1.2);
          g.addColorStop(0, `rgba(170,255,205,${0.42*a})`);
          g.addColorStop(0.55, `rgba(95,210,150,${0.30*a})`);
          g.addColorStop(1,'rgba(0,0,0,0)');
          fctx.fillStyle=g;
          fctx.beginPath(); fctx.arc(x,y,r,0,Math.PI*2); fctx.fill();
        }

        blob(cx-6+wob, crownY-6, crownR*1.02, 1);
        blob(cx-40+wob*0.6, crownY+10, crownR*0.62, 0.9);
        blob(cx+44-wob*0.5, crownY+18, crownR*0.58, 0.9);
        blob(cx+10-wob*0.4, crownY-44, crownR*0.54, 0.85);
      }

      function drawAxe(now){
        const cx=W*0.5;
        const trunkW = Math.min(98, Math.max(66, W*0.105));
        const t = clamp01((now - swingStart)/swingLife);

        const fromLeft = (swingSide==='left');
        const hitY = H*0.62;

        const startX = fromLeft ? (cx - trunkW*1.62) : (cx + trunkW*1.62);
        const endX   = fromLeft ? (cx - trunkW*0.58) : (cx + trunkW*0.58);
        const x = startX + (endX - startX) * easeOut(t);

        const startY = hitY - 70;
        const endY   = hitY + 10;
        const y = startY + (endY - startY) * easeIn(t);

        const rotStart = fromLeft ? -0.85 : 0.85;
        const rotEnd   = fromLeft ? 0.18 : -0.18;
        const rot = rotStart + (rotEnd - rotStart) * easeInOut(t);

        fctx.save();
        fctx.translate(x,y);
        fctx.rotate(rot);
        if (!fromLeft) fctx.scale(-1,1);

        fctx.save();
        fctx.shadowColor='rgba(0,0,0,0.35)';
        fctx.shadowBlur=14;
        fctx.shadowOffsetY=8;

        const handleGrad = fctx.createLinearGradient(-8,-60,8,60);
        handleGrad.addColorStop(0,'rgba(170,120,70,0.95)');
        handleGrad.addColorStop(1,'rgba(95,65,40,0.95)');
        fctx.fillStyle=handleGrad;
        roundRectPath(fctx, -6, -64, 12, 130, 8);
        fctx.fill();

        const bladeGrad = fctx.createRadialGradient(18,-38,8,12,-36,48);
        bladeGrad.addColorStop(0,'rgba(207,239,255,0.95)');
        bladeGrad.addColorStop(0.6,'rgba(159,216,255,0.55)');
        bladeGrad.addColorStop(1,'rgba(20,70,100,0.35)');
        fctx.fillStyle=bladeGrad;

        fctx.beginPath();
        fctx.moveTo(4,-55);
        fctx.lineTo(42,-44);
        fctx.quadraticCurveTo(52,-38,42,-28);
        fctx.lineTo(4,-18);
        fctx.closePath();
        fctx.fill();

        fctx.lineWidth=2;
        fctx.strokeStyle='rgba(207,239,255,0.30)';
        fctx.stroke();

        fctx.restore();
        fctx.restore();
      }

      function drawForestScene(now){
        drawForestBackLayer();
        drawForestTree(now);
        drawLeaves();

        const t = clamp01((now - swingStart) / swingLife);
        const urgent = t > 0.75;
        const cx=W*0.5;
        const trunkW = Math.min(98, Math.max(66, W*0.105));
        const kx = (swingSide==='left') ? cx - trunkW*0.95 : cx + trunkW*0.95;
        const ky = H*0.60;

        const needKey = (swingSide==='left') ? 'A' : 'D';
        fctx.beginPath();
        fctx.arc(kx,ky,22,0,Math.PI*2);
        fctx.fillStyle = urgent ? 'rgba(255,107,107,0.18)' : 'rgba(150,255,196,0.12)';
        fctx.fill();
        fctx.lineWidth=2;
        fctx.strokeStyle = urgent ? 'rgba(255,107,107,0.55)' : 'rgba(150,255,196,0.38)';
        fctx.stroke();
        fctx.font = '700 14px system-ui';
        fctx.fillStyle='rgba(234,247,255,0.95)';
        fctx.textAlign='center'; fctx.textBaseline='middle';
        fctx.fillText(needKey, kx, ky);

        const start=-Math.PI/2;
        fctx.beginPath();
        fctx.arc(kx,ky,28,start,start + Math.PI*2*(1-t));
        fctx.lineWidth=3;
        fctx.strokeStyle = urgent ? 'rgba(255,107,107,0.75)' : 'rgba(101,255,178,0.55)';
        fctx.stroke();

        drawAxe(now);
      }

      // ---------- Particles ----------
      function updateAndDrawParticles(now, dt){
        for(let i=particles.length-1;i>=0;i--){
          const p=particles[i];
          const age = now - p.born;
          if(age >= p.life){ particles.splice(i,1); continue; }
          const tt = age/p.life;
          const a = 1-tt;

          if(p.ring){
            const rr = p.r + tt*40;
            fctx.beginPath();
            fctx.arc(p.x,p.y,rr,0,Math.PI*2);
            fctx.lineWidth=2;
            const col = (p.kind==='wood') ? `rgba(255,214,120,${0.30*a})`
                      : (p.kind==='forge') ? `rgba(255,195,140,${0.30*a})`
                      : (p.kind==='fire') ? `rgba(255,145,70,${0.32*a})`
                      : (p.kind==='herb') ? `rgba(120,210,255,${0.30*a})`
                      : `rgba(207,239,255,${0.35*a})`;
            fctx.strokeStyle = col;
            fctx.stroke();
          } else {
            p.vy += 0.015*dt;
            p.x += p.vx*(dt/16.7);
            p.y += p.vy*(dt/16.7);
            p.vx *= 0.99; p.vy *= 0.99;

            fctx.beginPath();
            fctx.arc(p.x,p.y,p.r,0,Math.PI*2);
            const col = (p.kind==='wood') ? `rgba(255,214,120,${0.75*a})`
                      : (p.kind==='forge') ? `rgba(255,195,140,${0.75*a})`
                      : (p.kind==='fire') ? `rgba(255,145,70,${0.78*a})`
                      : (p.kind==='herb') ? `rgba(120,220,255,${0.78*a})`
                      : `rgba(207,239,255,${0.85*a})`;
            fctx.fillStyle = col;
            fctx.fill();
          }
        }
      }

      // ---------- Forge ----------
      const FORGE_KEYS = ['w','a','s','d'];
      let forgePhase = 'idle';
      let ore = null;
      let oreDrag = { on:false, dx:0, dy:0 };
      let swordSlots = [];
      let targetSlot = 0;

      let countdownStart = 0;
      const COUNTDOWN_MS = 3000;

      let qteSeq = [];
      let qteIndex = 0;
      let qteKeyDeadline = 0;

      const QTE_MISTAKES_ALLOWED = 0; // ‚ùå –±–µ–∑ –¥–æ–ø.–∂–∏–∑–Ω–∏
      let qteMistakes = 0;
      let qteRepeatPressed = 0; // –¥–ª—è "D D"

      let shakePower = 0;
      let shakeUntil = 0;

      const FAN_TURNS_TARGET = 15;
      const FAN_TOTAL_MS = 4500;

      let fan = {
        x:0, y:0, r:0,
        dragging:false,
        lastAng:0,
        lastT:0,
        omega:0,
        turns:0,
        turnsTarget:FAN_TURNS_TARGET,
        spawnedAt:0,
        caught:false,
        caughtAt:0,
        totalLimit:FAN_TOTAL_MS
      };

      // --- Forge: –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä SPACE (–µ—Å–ª–∏ –Ω–µ –Ω–∞–∂–∞–ª ‚Äî –ø–æ—Ä–∞–∂–µ–Ω–∏–µ) ---
      let forgeSpace = {
        active:false,
        x:0, y:0,
        born:0,
        ttl:10000,
        nextAt:0
      };

      function forgeSpaceSchedule(now){
        const k = clamp01((difficulty-1)/7);
        const minI = Math.max(600, 1700 - k*800);
        const maxI = Math.max(1100, 3400 - k*1400);
        forgeSpace.nextAt = now + rand(minI, maxI);
      }

      function forgeSpaceSpawn(now){
        const pad = 62;
        forgeSpace.active = true;
        forgeSpace.born = now;
        forgeSpace.ttl = 1100 + rand(-120, 220);
        forgeSpace.x = rand(pad, W - pad);
        forgeSpace.y = rand(pad + 80, H - pad - 50);
      }

      function forgeSpaceReset(now){
        forgeSpace.active = false;
        forgeSpace.born = 0;
        forgeSpaceSchedule(now);
      }
function drawForgeSpaceIndicator(now){
  if(!forgeSpace.active) return;

  const t = (now - forgeSpace.born) / forgeSpace.ttl; // 0..1
  const k = clamp01(t);
  const a = 1 - k;

  // –ª—ë–≥–∫–∞—è –ø—É–ª—å—Å–∞—Ü–∏—è
  const pulse = 1 + Math.sin(now*0.004)*0.03;

  fctx.save();

  // ===== FULLSCREEN –∑–∞—Ç–µ–º–Ω–µ–Ω–∏–µ + "—Ç—Ä–µ–≤–æ–≥–∞" =====
  // –±–µ–ª–æ-–∑–µ–ª—ë–Ω–∞—è –≤—Å–ø—ã—à–∫–∞ –ø–æ –∫—Ä–∞—è–º
  const vign = fctx.createRadialGradient(W*0.5, H*0.5, Math.min(W,H)*0.10, W*0.5, H*0.5, Math.max(W,H)*0.75);
  vign.addColorStop(0, `rgba(0,0,0,${0.15*a})`);
  vign.addColorStop(1, `rgba(90,255,190,${0.22*a})`);
  fctx.fillStyle = vign;
  fctx.fillRect(0,0,W,H);

  // –ø–æ–ª—É–ø—Ä–æ–∑—Ä–∞—á–Ω—ã–π —Å–ª–æ–π –ø–æ–≤–µ—Ä—Ö
  fctx.fillStyle = `rgba(0,0,0,${0.45*a})`;
  fctx.fillRect(0,0,W,H);

  // ===== –¶–ï–ù–¢–†–ê–õ–¨–ù–´–ô –¢–ï–ö–°–¢ –û–ì–†–û–ú–ù–´–ô =====
  const cx = W*0.5, cy = H*0.5;

  fctx.translate(cx, cy);
  fctx.scale(pulse, pulse);

  // –æ–≥—Ä–æ–º–Ω—ã–π —Ç–µ–∫—Å—Ç "–ü–†–û–ë–ï–õ"
  fctx.textAlign = 'center';
  fctx.textBaseline = 'middle';

  // —Ç–µ–Ω—å/–ø–æ–¥–ª–æ–∂–∫–∞
  fctx.font = `1000 ${Math.floor(Math.min(W,H)*0.12)}px system-ui`; // ~12% —ç–∫—Ä–∞–Ω–∞
  fctx.lineWidth = Math.max(10, Math.floor(Math.min(W,H)*0.01));
  fctx.strokeStyle = `rgba(0,0,0,${0.65*a})`;
  fctx.strokeText('–ü–†–û–ë–ï–õ', 0, -10);

  fctx.fillStyle = `rgba(240,255,250,${0.98*a})`;
  fctx.fillText('–ü–†–û–ë–ï–õ', 0, -10);

  // –ø–æ–¥–ø–∏—Å—å
  fctx.font = `900 ${Math.floor(Math.min(W,H)*0.045)}px system-ui`; // ~4.5% —ç–∫—Ä–∞–Ω–∞
  fctx.fillStyle = `rgba(90,255,190,${0.95*a})`;
  fctx.fillText('–ñ–ú–ò –ë–´–°–¢–†–û!', 0, Math.min(W,H)*0.10);

  // ===== –û–ì–†–û–ú–ù–û–ï –ö–û–õ–¨–¶–û-–¢–ê–ô–ú–ï–† (–ø–æ—á—Ç–∏ –Ω–∞ –≤–µ—Å—å —ç–∫—Ä–∞–Ω) =====
  const R = Math.min(W,H)*0.38; // —Ä–∞–¥–∏—É—Å –ø–æ—á—Ç–∏ –Ω–∞ –≤–µ—Å—å —ç–∫—Ä–∞–Ω
  const start = -Math.PI/2;

  // —Ñ–æ–Ω –∫–æ–ª—å—Ü–∞
  fctx.beginPath();
  fctx.arc(0,0,R,0,Math.PI*2);
  fctx.lineWidth = Math.max(14, Math.floor(Math.min(W,H)*0.012));
  fctx.strokeStyle = `rgba(255,255,255,${0.10*a})`;
  fctx.stroke();

  // –ø—Ä–æ–≥—Ä–µ—Å—Å (—É–º–µ–Ω—å—à–∞–µ—Ç—Å—è)
  fctx.beginPath();
  fctx.arc(0,0,R,start,start + Math.PI*2*(1-k));
  fctx.lineWidth = Math.max(18, Math.floor(Math.min(W,H)*0.016));
  fctx.strokeStyle = `rgba(255,200,120,${0.85*a})`;
  fctx.stroke();

  fctx.restore();
}



      function forgeLayout(){
        const anW = Math.min(520, Math.max(340, W*0.62));
        const anH = Math.min(150, Math.max(110, H*0.18));
        const anX = W*0.52 - anW*0.5;
        const anY = H*0.56;

        const bladeW = Math.min(560, Math.max(360, W*0.62));
        const bladeH = Math.min(88, Math.max(62, H*0.085));
        const bladeX = anX + anW*0.10;
        const bladeY = anY + anH*0.32;

        const slotW = bladeW*0.18;
        const slotH = bladeH*0.72;
        swordSlots = [];
        for(let i=0;i<4;i++){
          const cx = bladeX + bladeW*(0.18 + i*0.17);
          swordSlots.push({
            x: cx - slotW/2,
            y: bladeY + bladeH*0.14 - slotH/2 + bladeH*0.28,
            w: slotW,
            h: slotH
          });
        }

        const ox = W*0.18;
        const oy = H*0.64;
        if(!ore){
          ore = { x: ox, y: oy, r: Math.min(34, Math.max(26, W*0.03)) };
        }

        fan.r = Math.min(70, Math.max(52, W*0.06));
      }

      function randomFanPosition(){
        const pad = fan.r + 20;
        fan.x = rand(pad, W - pad);
        fan.y = rand(pad + 70, H - pad - 40);
      }

      function forgeResetRound(){
        forgeLayout();
        forgePhase = 'drag';
        oreDrag.on = false;
        ore.x = W*0.18;
        ore.y = H*0.64;
        targetSlot = (Math.random()*4)|0;

        qteSeq = [];
        qteIndex = 0;
        qteKeyDeadline = 0;
        countdownStart = 0;

        qteMistakes = 0;
        qteRepeatPressed = 0;

        fan.dragging=false;
        fan.omega=0;
        fan.turns=0;
        fan.caught=false;
        fan.turnsTarget = FAN_TURNS_TARGET;
      }

      function forgeBurst(x,y,rad){
        const n = Math.floor(16 + rad*0.5);
        for(let i=0;i<n;i++){
          const a=rand(0,Math.PI*2), sp=rand(1.0,4.6);
          particles.push({x,y,vx:Math.cos(a)*sp, vy:Math.sin(a)*sp, r:rand(1.2,3.2), life:rand(320,720), born:performance.now(), kind:'forge'});
        }
        particles.push({ring:true,x,y,r:Math.max(10,rad*0.6), life:220, born:performance.now(), kind:'forge'});
      }
      function pointInRect(px,py,r){
        return px>=r.x && px<=r.x+r.w && py>=r.y && py<=r.y+r.h;
      }
      function forgeStartCountdown(now){
        forgePhase = 'countdown';
        countdownStart = now;
      }
      function forgeStartQTE(now){
        forgePhase = 'qte';
        qteIndex = 0;
        qteMistakes = 0;
        qteRepeatPressed = 0;

        const len = Math.min(11, 5 + Math.floor((difficulty-1)*0.9));
        const twoChance = clamp01((difficulty-1)/6) * 0.45 + 0.12;

        qteSeq = Array.from({length:len}, ()=>{
          if(Math.random() < twoChance){
            const k = FORGE_KEYS[(Math.random()*4)|0];
            return k + k;
          }
          return FORGE_KEYS[(Math.random()*4)|0];
        });

        const per = Math.max(420, 900/(0.85 + difficulty*0.55));
        qteKeyDeadline = now + per;
      }

      function forgeStartFan(now){
        forgePhase = 'fan';
        randomFanPosition();
        fan.spawnedAt = now;
        fan.caught = false;
        fan.dragging = false;
        fan.lastAng = 0;
        fan.lastT = now;
        fan.omega = 0;
        fan.turns = 0;
        fan.turnsTarget = FAN_TURNS_TARGET;
        fan.caughtAt = 0;
        fan.totalLimit = FAN_TOTAL_MS;
      }

      function forgeCompleteOre(now){
        smashed++;
        score++;
        scoreEl.textContent = score;
        computeDifficulty();
        if (audioCtx && audioCtx.state === 'running') playAnvilHit(Math.min(1.6, 1 + difficulty*0.10));
        forgeBurst(W*0.52, H*0.60, 30);
        if (musicOn && audioCtx && audioCtx.state === 'running') startMusic();
        forgeResetRound();
      }

      function drawForgeScene(now){
        const baseShake = (forgePhase==='qte')
          ? (0.6 + clamp01((difficulty-1)/6)*2.6)
          : 0;

        let extra = 0;
        if(now < shakeUntil){
          const t = (shakeUntil - now)/120;
          extra = Math.max(0, t) * shakePower;
        }
        const amp = baseShake * (1 + extra);
        const sx = (amp>0) ? (rand(-1,1)*amp) : 0;
        const sy = (amp>0) ? (rand(-1,1)*amp) : 0;

        fctx.save();
        fctx.translate(sx, sy);

        const ember = fctx.createRadialGradient(W*0.35, H*0.78, 10, W*0.35, H*0.78, Math.max(W,H)*0.75);
        ember.addColorStop(0,'rgba(255,120,60,0.16)');
        ember.addColorStop(1,'rgba(0,0,0,0)');
        fctx.fillStyle = ember;
        fctx.fillRect(0,0,W,H);

        forgeLayout();

        const anW = Math.min(520, Math.max(340, W*0.62));
        const anH = Math.min(150, Math.max(110, H*0.18));
        const anX = W*0.52 - anW*0.5;
        const anY = H*0.56;

        fctx.save();
        fctx.shadowColor='rgba(0,0,0,0.45)';
        fctx.shadowBlur=26;
        fctx.shadowOffsetY=14;

        const anG = fctx.createLinearGradient(anX, anY, anX+anW, anY+anH);
        anG.addColorStop(0,'rgba(70,80,100,0.92)');
        anG.addColorStop(0.55,'rgba(140,160,190,0.60)');
        anG.addColorStop(1,'rgba(35,45,65,0.92)');
        fctx.fillStyle = anG;

        roundRectPath(fctx, anX, anY, anW, anH, 26);
        fctx.fill();
        fctx.restore();

        const bladeW = Math.min(560, Math.max(360, W*0.62));
        const bladeH = Math.min(88, Math.max(62, H*0.085));
        const bladeX = anX + anW*0.10;
        const bladeY = anY + anH*0.32;

        fctx.save();
        fctx.shadowColor='rgba(0,0,0,0.35)';
        fctx.shadowBlur=18;
        fctx.shadowOffsetY=10;

        const steel = fctx.createLinearGradient(bladeX, bladeY, bladeX+bladeW, bladeY+bladeH);
        steel.addColorStop(0,'rgba(215,235,255,0.80)');
        steel.addColorStop(0.55,'rgba(140,175,210,0.55)');
        steel.addColorStop(1,'rgba(60,90,120,0.65)');
        fctx.fillStyle = steel;

        roundRectPath(fctx, bladeX, bladeY, bladeW*0.86, bladeH, bladeH*0.45);
        fctx.fill();

        fctx.beginPath();
        fctx.moveTo(bladeX + bladeW*0.86, bladeY);
        fctx.lineTo(bladeX + bladeW, bladeY + bladeH*0.5);
        fctx.lineTo(bladeX + bladeW*0.86, bladeY + bladeH);
        fctx.closePath();
        fctx.fill();

        fctx.strokeStyle='rgba(255,255,255,0.10)';
        fctx.lineWidth = Math.max(2, bladeH*0.06);
        fctx.beginPath();
        fctx.moveTo(bladeX + bladeW*0.08, bladeY + bladeH*0.50);
        fctx.lineTo(bladeX + bladeW*0.80, bladeY + bladeH*0.50);
        fctx.stroke();

        const guardW = bladeH*0.75, guardH = bladeH*0.70;
        const gX = bladeX - guardW*0.55;
        const gY = bladeY + bladeH*0.15;
        const guardGrad = fctx.createLinearGradient(gX, gY, gX+guardW, gY+guardH);
        guardGrad.addColorStop(0,'rgba(255,195,140,0.35)');
        guardGrad.addColorStop(1,'rgba(70,50,40,0.85)');
        fctx.fillStyle = guardGrad;
        roundRectPath(fctx, gX, gY, guardW, guardH, 12);
        fctx.fill();

        const hW = bladeH*0.95, hH = bladeH*0.38;
        const hX = gX - hW*0.82;
        const hY = bladeY + bladeH*0.31;
        const handleGrad = fctx.createLinearGradient(hX, hY, hX+hW, hY+hH);
        handleGrad.addColorStop(0,'rgba(120,80,55,0.95)');
        handleGrad.addColorStop(1,'rgba(70,45,30,0.95)');
        fctx.fillStyle = handleGrad;
        roundRectPath(fctx, hX, hY, hW, hH, 10);
        fctx.fill();

        fctx.fillStyle='rgba(255,195,140,0.25)';
        fctx.beginPath();
        fctx.arc(hX, hY+hH*0.5, hH*0.62, 0, Math.PI*2);
        fctx.fill();

        fctx.restore();

        for(let i=0;i<swordSlots.length;i++){
          const s = swordSlots[i];
          const isTarget = (i===targetSlot) && (forgePhase==='drag');
          const glow = isTarget ? 1 : 0;
          fctx.save();
          if(glow){
            fctx.shadowColor='rgba(255,195,140,0.70)';
            fctx.shadowBlur=18;
          }
          fctx.fillStyle = glow ? 'rgba(255,195,140,0.14)' : 'rgba(0,0,0,0.10)';
          roundRectPath(fctx, s.x, s.y, s.w, s.h, 14);
          fctx.fill();
          fctx.lineWidth=2;
          fctx.strokeStyle = glow ? 'rgba(255,195,140,0.45)' : 'rgba(207,239,255,0.12)';
          fctx.stroke();
          fctx.restore();
        }

        if(ore){
          fctx.save();
          fctx.shadowColor='rgba(0,0,0,0.45)';
          fctx.shadowBlur=18;
          fctx.shadowOffsetY=10;

          const rg = fctx.createRadialGradient(ore.x-ore.r*0.2, ore.y-ore.r*0.3, ore.r*0.2, ore.x, ore.y, ore.r*1.2);
          rg.addColorStop(0,'rgba(255,214,120,0.55)');
          rg.addColorStop(0.55,'rgba(255,145,70,0.35)');
          rg.addColorStop(1,'rgba(50,55,70,0.85)');
          fctx.fillStyle = rg;

          const pts=10;
          fctx.beginPath();
          for(let i=0;i<=pts;i++){
            const a = (i/pts)*Math.PI*2 + 0.4;
            const wob = 0.16*Math.sin(a*3) + 0.08*Math.cos(a*5);
            const rr = ore.r*(1+wob);
            const x = ore.x + Math.cos(a)*rr;
            const y = ore.y + Math.sin(a)*rr;
            if(i===0) fctx.moveTo(x,y); else fctx.lineTo(x,y);
          }
          fctx.closePath();
          fctx.fill();

          fctx.lineWidth=2;
          fctx.strokeStyle='rgba(255,195,140,0.18)';
          fctx.stroke();

          fctx.restore();
        }

        if(forgePhase==='fan'){
          drawFan(now);
        }

        fctx.font = '700 14px system-ui';
        fctx.fillStyle='rgba(234,247,255,0.92)';
        fctx.textAlign='left';
        fctx.textBaseline='top';

        if(forgePhase==='drag'){
          fctx.fillText('–ö—É–∑–Ω–∏—Ü–∞: –ø–µ—Ä–µ—Ç–∞—â–∏ —Ä—É–¥—É –Ω–∞ –ø–æ–¥—Å–≤–µ—á–µ–Ω–Ω—É—é –∑–æ–Ω—É –º–µ—á–∞.', 18, 78);
        } else if(forgePhase==='countdown'){
          const t = clamp01((now - countdownStart) / COUNTDOWN_MS);
          const left = Math.max(0, COUNTDOWN_MS - (now - countdownStart));
          const seconds = Math.ceil(left/1000);
          fctx.fillText('–ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞... —Å–∫–æ—Ä–æ –Ω–∞—á–Ω—ë—Ç—Å—è –ø—Ä–æ–≤–µ—Ä–∫–∞.', 18, 78);

          const cx2 = W*0.52, cy2 = H*0.18;
          fctx.save();
          fctx.beginPath();
          fctx.arc(cx2, cy2, 30, 0, Math.PI*2);
          fctx.fillStyle='rgba(255,195,140,0.10)';
          fctx.fill();

          const start = -Math.PI/2;
          fctx.beginPath();
          fctx.arc(cx2, cy2, 36, start, start + Math.PI*2*(1-t));
          fctx.lineWidth=4;
          fctx.strokeStyle='rgba(255,195,140,0.65)';
          fctx.stroke();

          fctx.font = '900 22px system-ui';
          fctx.fillStyle='rgba(234,247,255,0.95)';
          fctx.textAlign='center';
          fctx.textBaseline='middle';
          fctx.fillText(String(seconds), cx2, cy2);
          fctx.restore();
        } else if(forgePhase==='qte'){
          const cur = qteSeq[qteIndex] || '';
          const per = Math.max(420, 900/(0.85 + difficulty*0.55));
          const remain = Math.max(0, qteKeyDeadline - now);
          const k = clamp01(remain / per);

          fctx.fillText('QTE: –Ω–∞–∂–∏–º–∞–π –ø—Ä–∞–≤–∏–ª—å–Ω–æ –∏ –±—ã—Å—Ç—Ä–æ! (–∏–Ω–æ–≥–¥–∞ D D)', 18, 78);

          const bx = W*0.18, by = H*0.16;
          fctx.save();
          fctx.shadowColor='rgba(0,0,0,0.35)';
          fctx.shadowBlur=18;
          fctx.shadowOffsetY=10;

          roundRectPath(fctx, bx, by, 160, 92, 18);
          fctx.fillStyle='rgba(255,195,140,0.10)';
          fctx.fill();
          fctx.lineWidth=2;
          fctx.strokeStyle='rgba(255,195,140,0.30)';
          fctx.stroke();

          fctx.font = '1000 40px system-ui';
          fctx.fillStyle='rgba(234,247,255,0.95)';
          fctx.textAlign='center';
          fctx.textBaseline='middle';

          const shown = (cur.length===2)
            ? `${cur[0].toUpperCase()} ${cur[1].toUpperCase()}`
            : cur.toUpperCase();

          fctx.fillText(shown, bx+80, by+45);

          roundRectPath(fctx, bx, by+102, 160, 10, 8);
          fctx.fillStyle='rgba(255,255,255,0.08)';
          fctx.fill();
          roundRectPath(fctx, bx, by+102, 160*k, 10, 8);
          fctx.fillStyle = (k<0.25) ? 'rgba(255,107,107,0.70)' : 'rgba(255,195,140,0.70)';
          fctx.fill();

          fctx.restore();

          fctx.font = '700 12px system-ui';
          fctx.fillStyle='rgba(234,247,255,0.85)';
          fctx.textAlign='left';
          fctx.textBaseline='top';
          fctx.fillText(`–ü—Ä–æ–≥—Ä–µ—Å—Å: ${qteIndex}/${qteSeq.length}`, 18, 108);
        } else if(forgePhase==='fan'){
          const elapsed = now - fan.spawnedAt;
          const left = Math.max(0, fan.totalLimit - elapsed);
          const prog = clamp01(fan.turns / fan.turnsTarget);
          fctx.fillText(`–í–µ–Ω—Ç–∏–ª—è—Ç–æ—Ä: ${fan.turns.toFixed(1)} / ${fan.turnsTarget} –æ–±–æ—Ä–æ—Ç–æ–≤`, 18, 78);
          fctx.fillText(`–û—Å—Ç–∞–ª–æ—Å—å: ${(left/1000).toFixed(1)}—Å (–≤—Å–µ–≥–æ –ª–∏–º–∏—Ç)`, 18, 98);

          const bx = 18, by = 124, bw = 260, bh = 10;
          roundRectPath(fctx, bx, by, bw, bh, 8);
          fctx.fillStyle='rgba(255,255,255,0.08)';
          fctx.fill();
          roundRectPath(fctx, bx, by, bw*(left/fan.totalLimit), bh, 8);
          fctx.fillStyle = (left<700) ? 'rgba(255,107,107,0.70)' : 'rgba(255,195,140,0.70)';
          fctx.fill();

          const bx2 = 18, by2 = 142, bw2 = 260, bh2 = 10;
          roundRectPath(fctx, bx2, by2, bw2, bh2, 8);
          fctx.fillStyle='rgba(255,255,255,0.08)';
          fctx.fill();
          roundRectPath(fctx, bx2, by2, bw2*prog, bh2, 8);
          fctx.fillStyle='rgba(101,255,178,0.55)';
          fctx.fill();
        }

        // ‚úÖ —Ä–∏—Å—É–µ–º –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä SPACE –ø–æ–≤–µ—Ä—Ö —Å—Ü–µ–Ω—ã (–µ—Å–ª–∏ –∞–∫—Ç–∏–≤–µ–Ω)
        drawForgeSpaceIndicator(now);

        fctx.restore();

        function drawFan(now){
          const x = fan.x, y = fan.y, r = fan.r;
          const pulse = (!fan.caught) ? (1 + Math.sin(now*0.01)*0.06) : 1;

          fctx.save();
          fctx.translate(x,y);
          fctx.scale(pulse,pulse);

          fctx.save();
          fctx.shadowColor='rgba(0,0,0,0.45)';
          fctx.shadowBlur=18;
          fctx.shadowOffsetY=10;

          const rim = fctx.createRadialGradient(-r*0.2, -r*0.2, 8, 0, 0, r*1.2);
          rim.addColorStop(0,'rgba(255,214,120,0.35)');
          rim.addColorStop(0.55,'rgba(255,145,70,0.18)');
          rim.addColorStop(1,'rgba(30,35,45,0.70)');
          fctx.fillStyle = rim;
          fctx.beginPath(); fctx.arc(0,0,r,0,Math.PI*2); fctx.fill();
          fctx.lineWidth=2;
          fctx.strokeStyle = fan.caught ? 'rgba(101,255,178,0.30)' : 'rgba(255,195,140,0.22)';
          fctx.stroke();

          fctx.strokeStyle = 'rgba(255,195,140,0.14)';
          fctx.lineWidth = 2;
          fctx.beginPath(); fctx.arc(0,0,r*0.78,0,Math.PI*2); fctx.stroke();
          fctx.beginPath(); fctx.arc(0,0,r*0.55,0,Math.PI*2); fctx.stroke();

          const blades = 7;
          const ang0 = now*0.002 + fan.omega*0.02;
          for(let i=0;i<blades;i++){
            const a = ang0 + i*(Math.PI*2/blades);
            fctx.save();
            fctx.rotate(a);
            const bG = fctx.createLinearGradient(0, -r*0.08, r*0.85, r*0.08);
            bG.addColorStop(0,'rgba(255,195,140,0.22)');
            bG.addColorStop(1,'rgba(207,239,255,0.10)');
            fctx.fillStyle = bG;
            roundRectPath(fctx, r*0.12, -r*0.12, r*0.78, r*0.24, r*0.12);
            fctx.fill();
            fctx.restore();
          }

          fctx.fillStyle='rgba(6,18,32,0.35)';
          fctx.beginPath(); fctx.arc(0,0,r*0.22,0,Math.PI*2); fctx.fill();
          fctx.strokeStyle='rgba(255,195,140,0.35)';
          fctx.lineWidth=2;
          fctx.beginPath(); fctx.arc(0,0,r*0.22,0,Math.PI*2); fctx.stroke();

          fctx.restore();

          const prog = clamp01(fan.turns / fan.turnsTarget);
          const start = -Math.PI/2;
          fctx.beginPath();
          fctx.arc(0,0,r+10,start,start + Math.PI*2*prog);
          fctx.lineWidth=4;
          fctx.strokeStyle = 'rgba(101,255,178,0.45)';
          fctx.stroke();

          if(!fan.caught){
            fctx.font='800 12px system-ui';
            fctx.fillStyle='rgba(234,247,255,0.85)';
            fctx.textAlign='center';
            fctx.textBaseline='middle';
            fctx.fillText('–°–•–í–ê–¢–ò', 0, r+22);
          }

          fctx.restore();
        }
      }

      // ---------- Herbs Mode 1 (Frost) ----------
      let herbs = [];
      let herbSpawnTimer = 0;
      let herbNextSpawn = 800;

      const HERB_HOLD_LIMIT_MS = 850;
      const HERB_SNOW_FADE_MS = 3000;
      let herbPointerDown = false;
      let herbDownAt = 0;
      let stroke = [];
      let lastSpaceAt = performance.now();
      let snowWhite = 0;

      function herbScheduleNext(){
        const base=820, min=220;
        const interval = Math.max(min, base/(0.85 + difficulty*0.85));
        herbNextSpawn = interval + rand(-70, 90);
      }
      function herbLifetime(){
        const base=1050, min=360;
        const life = Math.max(min, base/(0.85 + difficulty*0.95));
        return life + rand(-60, 90);
      }
      function spawnHerb(now){
        const x = rand(70, W-70);
        const y = rand(H*0.48, H*0.86);
        const h = rand(70, 140) * (0.95 + Math.min(0.25, score/90));
        const tilt = rand(-0.45, 0.45);
        const spikes = 6 + ((Math.random()*5)|0);
        herbs.push({
          x,y,
          h,
          tilt,
          spikes,
          born: now,
          life: herbLifetime(),
          cut:false
        });
        spawned++;
      }
      function herbBurst(x,y){
        const n = 18 + (Math.random()*10|0);
        for(let i=0;i<n;i++){
          const a=rand(0,Math.PI*2), sp=rand(1.0,4.8);
          particles.push({x,y,vx:Math.cos(a)*sp, vy:Math.sin(a)*sp - rand(0.6,1.8), r:rand(1.1,3.2), life:rand(320,720), born:performance.now(), kind:'herb'});
        }
        particles.push({ring:true,x,y,r:18, life:220, born:performance.now(), kind:'herb'});
      }
      function drawHerb(hb, now){
        const age = now - hb.born;
        const k = Math.min(1, age / hb.life);
        const alpha = 1 - Math.max(0,(k-0.88)/0.12)*0.85;
        const urgent = k>0.78;

        const baseX = hb.x;
        const baseY = hb.y;
        const topX = baseX + Math.sin(hb.tilt)*hb.h;
        const topY = baseY - Math.cos(hb.tilt)*hb.h;

        fctx.save();
        fctx.shadowColor = urgent ? 'rgba(255,107,107,0.25)' : 'rgba(159,216,255,0.22)';
        fctx.shadowBlur = 18;
        fctx.lineCap='round';

        const stemGrad = fctx.createLinearGradient(baseX, baseY, topX, topY);
        stemGrad.addColorStop(0, `rgba(120,210,255,${0.30*alpha})`);
        stemGrad.addColorStop(0.55, `rgba(110,180,255,${0.55*alpha})`);
        stemGrad.addColorStop(1, `rgba(200,245,255,${0.85*alpha})`);

        fctx.strokeStyle = stemGrad;
        fctx.lineWidth = 6;
        fctx.beginPath();
        fctx.moveTo(baseX, baseY);
        fctx.quadraticCurveTo((baseX+topX)/2 + Math.sin(age*0.01)*6, (baseY+topY)/2, topX, topY);
        fctx.stroke();

        const grown = clamp01(age / (hb.life*0.55));
        const count = hb.spikes;
        for(let i=0;i<count;i++){
          const t = (i+1)/(count+1);
          if(t > grown) continue;
          const px = baseX + (topX - baseX)*t;
          const py = baseY + (topY - baseY)*t;
          const nx = -(topY - baseY);
          const ny =  (topX - baseX);
          const nl = Math.hypot(nx,ny) || 1;
          const ux = nx/nl, uy = ny/nl;
          const side = (i%2===0) ? 1 : -1;
          const len = 10 + 16*(t*0.8) + 8*Math.sin(age*0.004 + i);
          const sx = px + ux*len*side;
          const sy = py + uy*len*side;

          fctx.fillStyle = `rgba(207,239,255,${0.62*alpha})`;
          fctx.beginPath();
          fctx.moveTo(px,py);
          fctx.lineTo(px + ux*6*side, py + uy*6*side);
          fctx.lineTo(sx,sy);
          fctx.closePath();
          fctx.fill();
        }

        const r = 20;
        const cx = topX, cy = topY;
        const start = -Math.PI/2;
        fctx.beginPath();
        fctx.arc(cx, cy, r, start, start + Math.PI*2*(1-k));
        fctx.lineWidth = 3;
        fctx.strokeStyle = urgent ? `rgba(255,107,107,${0.75*alpha})` : `rgba(101,255,178,${0.55*alpha})`;
        fctx.stroke();

        fctx.restore();
        return { k, baseX, baseY, topX, topY };
      }

      function distPointToSegment(px,py, ax,ay, bx,by){
        const abx = bx-ax, aby = by-ay;
        const apx = px-ax, apy = py-ay;
        const ab2 = abx*abx + aby*aby || 1;
        let t = (apx*abx + apy*aby)/ab2;
        t = Math.max(0, Math.min(1, t));
        const cx = ax + abx*t;
        const cy = ay + aby*t;
        const dx = px - cx, dy = py - cy;
        return Math.hypot(dx,dy);
      }

      function tryCutHerbWithPoint(px,py, now){
        for(let i=herbs.length-1;i>=0;i--){
          const hb = herbs[i];
          if(hb.cut) continue;
          const baseX = hb.x;
          const baseY = hb.y;
          const topX = baseX + Math.sin(hb.tilt)*hb.h;
          const topY = baseY - Math.cos(hb.tilt)*hb.h;

          const d = distPointToSegment(px,py, baseX,baseY, topX,topY);
          const thr = 14;
          if(d <= thr){
            hb.cut = true;
            smashed++;
            score++;
            scoreEl.textContent = score;
            computeDifficulty();
            missesStreak = 0;
            updateMissesUI();
            herbBurst(px,py);
            if(audioCtx && audioCtx.state==='running') playHerbSlice(Math.min(1.6, 1 + difficulty*0.10));
            herbs.splice(i,1);
            herbScheduleNext();
            if (musicOn && audioCtx && audioCtx.state === 'running') startMusic();
            return true;
          }
        }
        return false;
      }

      function drawStroke(){
        if(stroke.length < 2) return;
        fctx.save();
        fctx.lineCap='round';
        fctx.lineJoin='round';
        fctx.shadowColor='rgba(159,216,255,0.35)';
        fctx.shadowBlur=16;
        fctx.strokeStyle='rgba(207,239,255,0.35)';
        fctx.lineWidth=6;
        fctx.beginPath();
        fctx.moveTo(stroke[0].x, stroke[0].y);
        for(let i=1;i<stroke.length;i++){
          fctx.lineTo(stroke[i].x, stroke[i].y);
        }
        fctx.stroke();
        fctx.restore();
      }

      function updateSnowOverlay(now){
        const dtNoSpace = now - lastSpaceAt;
        snowWhite = clamp01(dtNoSpace / HERB_SNOW_FADE_MS);
        if(snowWhite >= 1) lose('snowed');

        if(snowWhite > 0){
          fctx.save();
          fctx.fillStyle = `rgba(255,255,255,${0.92*snowWhite})`;
          fctx.fillRect(0,0,W,H);
          fctx.restore();
        }
      }

      // ---------- Herbs Mode 2 (Fire bush + berries + basket) ----------
      let fireBush = { x:0, y:0, w:0, h:0 };
      let fireBerries = [];
      let basket = { x:0, y:0, w:0, h:0 };
      let fireRoundLimit = 0;
      let fireRoundStart = 0;
      let fireBerryCount = 3;
      let fireCaughtThisRound = 0;
      let fireRoundNumber = 0;

      function fireLayout(){
        fireBush.x = W*0.5;
        fireBush.y = H*0.68;
        fireBush.w = Math.min(360, Math.max(260, W*0.56));
        fireBush.h = Math.min(220, Math.max(160, H*0.24));
        basket.w = Math.min(220, Math.max(160, W*0.28));
        basket.h = Math.min(64, Math.max(48, H*0.07));
        basket.y = H - basket.h - 26;
        if(!basket.x) basket.x = W*0.5;
      }

      function fireBurst(x,y,rad){
        const n = 16 + ((rad*0.4)|0);
        for(let i=0;i<n;i++){
          const a=rand(0,Math.PI*2), sp=rand(0.8,4.6);
          particles.push({x,y,vx:Math.cos(a)*sp, vy:Math.sin(a)*sp - rand(0.2,1.4), r:rand(1.0,3.0), life:rand(260,680), born:performance.now(), kind:'fire'});
        }
        particles.push({ring:true,x,y,r:Math.max(10,rad*0.55), life:220, born:performance.now(), kind:'fire'});
      }

      function fireStartRound(now){
        fireLayout();
        fireRoundNumber++;
        fireCaughtThisRound = 0;
        fireBerries.length = 0;

        const count = fireBerryCount;
        const arcW = fireBush.w*0.42;
        for(let i=0;i<count;i++){
          const px = fireBush.x + rand(-arcW, arcW);
          const py = (fireBush.y - fireBush.h*0.30) + rand(-fireBush.h*0.18, fireBush.h*0.14);
          fireBerries.push({
            x:px, y:py,
            r: Math.min(16, Math.max(12, W*0.016)),
            state:'rest',
            vy: 0
          });
        }

        fireRoundStart = now;
        fireRoundLimit = Math.max(1400, 3400/(0.90 + difficulty*0.45));
      }

      function drawFireScene(now){
        fireLayout();

        const glow = fctx.createRadialGradient(fireBush.x, fireBush.y, 10, fireBush.x, fireBush.y, Math.max(W,H)*0.6);
        glow.addColorStop(0,'rgba(255,120,60,0.18)');
        glow.addColorStop(1,'rgba(0,0,0,0)');
        fctx.fillStyle=glow; fctx.fillRect(0,0,W,H);

        const ground = fctx.createLinearGradient(0, H*0.62, 0, H);
        ground.addColorStop(0,'rgba(0,0,0,0.00)');
        ground.addColorStop(0.65,'rgba(10,6,4,0.18)');
        ground.addColorStop(1,'rgba(10,6,4,0.32)');
        fctx.fillStyle=ground; fctx.fillRect(0,0,W,H);

        const bx = fireBush.x, by = fireBush.y;
        const bw = fireBush.w, bh = fireBush.h;

        fctx.save();
        fctx.shadowColor='rgba(0,0,0,0.50)';
        fctx.shadowBlur=22;
        fctx.shadowOffsetY=12;

        const bushGrad = fctx.createRadialGradient(bx-bw*0.15, by-bh*0.22, 10, bx, by, bw*0.65);
        bushGrad.addColorStop(0,'rgba(255,214,120,0.22)');
        bushGrad.addColorStop(0.35,'rgba(255,145,70,0.22)');
        bushGrad.addColorStop(1,'rgba(30,20,16,0.90)');
        fctx.fillStyle=bushGrad;

        fctx.beginPath();
        const pts=14;
        for(let i=0;i<=pts;i++){
          const t = i/pts;
          const a = Math.PI + t*Math.PI;
          const wob = 0.16*Math.sin(t*8 + now*0.0013) + 0.08*Math.cos(t*6 - now*0.0011);
          const rx = (bw*0.48)*(1+wob);
          const ry = (bh*0.32)*(1+wob*0.5);
          const x = bx + Math.cos(a)*rx;
          const y = by + Math.sin(a)*ry;
          if(i===0) fctx.moveTo(x,y);
          else fctx.lineTo(x,y);
        }
        const topY = by - bh*0.42;
        for(let i=0;i<10;i++){
          const tx = bx + rand(-bw*0.36, bw*0.36);
          const h = rand(bh*0.10, bh*0.26);
          fctx.quadraticCurveTo(tx, topY - h, tx + rand(-18,18), topY + rand(-8,10));
        }
        fctx.closePath();
        fctx.fill();

        for(let i=0;i<8;i++){
          const gx = bx + rand(-bw*0.25,bw*0.25);
          const gy = by - rand(bh*0.10,bh*0.34);
          const rr = rand(20, 55);
          const g2 = fctx.createRadialGradient(gx,gy,10,gx,gy,rr);
          g2.addColorStop(0,'rgba(255,214,120,0.20)');
          g2.addColorStop(1,'rgba(0,0,0,0)');
          fctx.fillStyle=g2;
          fctx.beginPath(); fctx.arc(gx,gy,rr,0,Math.PI*2); fctx.fill();
        }

        fctx.restore();

        for(const b of fireBerries){
          const pulse = 1 + Math.sin((now*0.008) + b.x*0.01)*0.06;
          fctx.save();
          fctx.shadowColor='rgba(255,120,60,0.40)';
          fctx.shadowBlur=16;
          const g = fctx.createRadialGradient(b.x-b.r*0.25, b.y-b.r*0.25, 2, b.x, b.y, b.r*1.3);
          g.addColorStop(0,'rgba(255,214,120,0.90)');
          g.addColorStop(0.45,'rgba(255,90,50,0.85)');
          g.addColorStop(1,'rgba(120,18,12,0.75)');
          fctx.fillStyle=g;
          fctx.beginPath();
          fctx.arc(b.x,b.y,b.r*pulse,0,Math.PI*2);
          fctx.fill();

          fctx.fillStyle='rgba(255,255,255,0.10)';
          fctx.beginPath();
          fctx.arc(b.x-b.r*0.25, b.y-b.r*0.25, b.r*0.28, 0, Math.PI*2);
          fctx.fill();
          fctx.restore();
        }

        basket.x = Math.max(basket.w*0.5+10, Math.min(W-basket.w*0.5-10, basket.x));
        const x = basket.x - basket.w*0.5;
        const y = basket.y;
        fctx.save();
        fctx.shadowColor='rgba(0,0,0,0.50)';
        fctx.shadowBlur=18;
        fctx.shadowOffsetY=10;

        const wood = fctx.createLinearGradient(x,y,x+basket.w,y+basket.h);
        wood.addColorStop(0,'rgba(160,112,70,0.70)');
        wood.addColorStop(1,'rgba(70,45,30,0.85)');
        fctx.fillStyle=wood;
        roundRectPath(fctx, x, y, basket.w, basket.h, 18);
        fctx.fill();

        fctx.strokeStyle='rgba(255,214,120,0.16)';
        fctx.lineWidth=2;
        roundRectPath(fctx, x+10, y+10, basket.w-20, basket.h-20, 14);
        fctx.stroke();
        fctx.restore();

        const timeLeft = Math.max(0, fireRoundLimit - (now - fireRoundStart));
        const pTime = clamp01(timeLeft / fireRoundLimit);
        const pGoal = clamp01(fireCaughtThisRound / Math.max(1, fireBerryCount));

        fctx.save();
        fctx.font='700 14px system-ui';
        fctx.fillStyle='rgba(234,247,255,0.92)';
        fctx.textAlign='left';
        fctx.textBaseline='top';
        fctx.fillText(`–û–≥–Ω–µ–Ω–Ω—ã–π –∫—É—Å—Ç: –ø–æ–π–º–∞–π ${fireCaughtThisRound}/${fireBerryCount} —è–≥–æ–¥`, 18, 78);
        fctx.fillText(`–í—Ä–µ–º—è: ${(timeLeft/1000).toFixed(1)}—Å`, 18, 98);

        const bx2=18, by2=124, bw2=260, bh2=10;
        roundRectPath(fctx, bx2, by2, bw2, bh2, 8);
        fctx.fillStyle='rgba(255,255,255,0.08)';
        fctx.fill();
        roundRectPath(fctx, bx2, by2, bw2*pTime, bh2, 8);
        fctx.fillStyle = (pTime<0.25) ? 'rgba(255,107,107,0.75)' : 'rgba(255,195,140,0.70)';
        fctx.fill();

        const bx3=18, by3=142;
        roundRectPath(fctx, bx3, by3, bw2, bh2, 8);
        fctx.fillStyle='rgba(255,255,255,0.08)';
        fctx.fill();
        roundRectPath(fctx, bx3, by3, bw2*pGoal, bh2, 8);
        fctx.fillStyle='rgba(101,255,178,0.55)';
        fctx.fill();

        fctx.restore();
      }

      function fireUpdate(now, dt){
        for(const b of fireBerries){
          if(b.state === 'rest'){
            const chance = 0.0006 + difficulty * 0.00025;
            if(Math.random() < chance * (dt/16.7)){
              b.state = 'fall';
              b.vy = (1.6 + difficulty*0.22) * (0.9 + Math.random()*0.3);
              spawned++;
              fireBurst(b.x,b.y,10);
              if(audioCtx && audioCtx.state==='running') playFirePop(0.7);
            }
          }
        }

        if(now - fireRoundStart > fireRoundLimit){
          lose('fire_timeout');
          return;
        }

        const basketLeft = basket.x - basket.w*0.5;
        const basketRight = basket.x + basket.w*0.5;
        const catchY = basket.y + basket.h*0.30;

        for(let i=fireBerries.length-1;i>=0;i--){
          const b = fireBerries[i];
          if(b.state !== 'fall') continue;

          b.vy += (0.55 + 0.08*difficulty) * (dt/16.7);
          b.y += b.vy * (dt/16.7);

          if(b.y >= catchY && b.y <= basket.y + basket.h){
            if(b.x >= basketLeft && b.x <= basketRight){
              fireCaughtThisRound++;
              smashed++;
              score++;
              scoreEl.textContent = score;
              computeDifficulty();
              missesStreak=0;
              updateMissesUI();

              fireRoundLimit += 250;

              fireBurst(b.x,b.y,18);
              if(audioCtx && audioCtx.state==='running') playFirePop(Math.min(1.6, 1 + difficulty*0.10));
              fireBerries.splice(i,1);

              if (musicOn && audioCtx && audioCtx.state === 'running') startMusic();

              if(fireCaughtThisRound >= fireBerryCount){
                fireBerryCount++;
                fireStartRound(now+10);
              }
              continue;
            }
          }

          if(b.y > H + 40){
            lose('fire_missed');
            return;
          }
        }
      }

      function fireHitBerry(px,py, now){
        for(let i=fireBerries.length-1;i>=0;i--){
          const b = fireBerries[i];
          if(b.state !== 'rest') continue;
          const dx = px - b.x, dy = py - b.y;
          if(dx*dx + dy*dy <= (b.r*b.r)){
            b.state = 'fall';
            b.vy = (2.2 + difficulty*0.25) * (0.9 + Math.random()*0.2);
            spawned++;
            fireBurst(b.x,b.y,12);
            if(audioCtx && audioCtx.state==='running') playFirePop(0.85);
            return true;
          }
        }
        return false;
      }

      // ---------- Input ----------
      function getPointerPos(e){
        const rect = fx.getBoundingClientRect();
        return { x: e.clientX - rect.left, y: e.clientY - rect.top };
      }
      function dist2(ax,ay,bx,by){ const dx=ax-bx, dy=ay-by; return dx*dx+dy*dy; }

      fx.addEventListener('pointerdown', (e)=>{
        if(!running || paused || lost) return;
        const {x,y} = getPointerPos(e);

        if(mode==='mines'){
          const ok = hitRock(x,y);
          if(ok){
            burstIce(x,y,18);
          } else {
            missesStreak++;
            updateMissesUI();
            burstIce(x,y,10);
            if(missesStreak>=MAX_MISSES) lose('miss_clicks');
          }
          return;
        }

        if(mode==='herbs'){
          herbPointerDown = true;
          herbDownAt = performance.now();
          stroke.length = 0;
          stroke.push({x,y,t:herbDownAt});
          fx.setPointerCapture(e.pointerId);
          tryCutHerbWithPoint(x,y, herbDownAt);
          return;
        }

        if(mode==='herbs_fire'){
          fireHitBerry(x,y, performance.now());
          return;
        }

        if(mode==='forge'){
          if(forgePhase==='drag'){
            if(!ore) return;
            if(dist2(x,y,ore.x,ore.y) <= ore.r*ore.r){
              oreDrag.on = true;
              oreDrag.dx = ore.x - x;
              oreDrag.dy = ore.y - y;
              fx.setPointerCapture(e.pointerId);
            }
            return;
          }
          if(forgePhase==='fan'){
            const dx = x - fan.x, dy = y - fan.y;
            if(dx*dx+dy*dy <= (fan.r*fan.r)){
              fan.dragging = true;
              const now = performance.now();
              fan.lastAng = Math.atan2(dy, dx);
              fan.lastT = now;
              if(!fan.caught){
                fan.caught = true;
                fan.caughtAt = now;
              }
              fx.setPointerCapture(e.pointerId);
            }
            return;
          }
        }
      }, {passive:true});

      fx.addEventListener('pointermove', (e)=>{
        if(!running || paused || lost) return;
        const {x,y} = getPointerPos(e);

        if(mode==='herbs'){
          if(!herbPointerDown) return;
          const now = performance.now();
          stroke.push({x,y,t:now});
          if(stroke.length > 24) stroke.shift();
          tryCutHerbWithPoint(x,y, now);
          return;
        }

        if(mode==='herbs_fire'){
          basket.x = x;
          return;
        }

        if(mode!=='forge') return;

        if(forgePhase==='drag'){
          if(!oreDrag.on || !ore) return;
          ore.x = x + oreDrag.dx;
          ore.y = y + oreDrag.dy;
          return;
        }

        if(forgePhase==='fan'){
          if(!fan.dragging) return;
          const now = performance.now();
          const ang = Math.atan2(y - fan.y, x - fan.x);
          let dA = ang - fan.lastAng;
          while(dA > Math.PI) dA -= Math.PI*2;
          while(dA < -Math.PI) dA += Math.PI*2;

          const dt = Math.max(1, now - fan.lastT);
          const instOmega = dA / (dt/1000);
          fan.omega = fan.omega*0.85 + instOmega*0.15;

          fan.turns += Math.abs(dA) / (Math.PI*2);

          fan.lastAng = ang;
          fan.lastT = now;
          return;
        }
      }, {passive:true});

      fx.addEventListener('pointerup', (e)=>{
        if(mode==='herbs'){
          herbPointerDown = false;
          stroke.length = 0;
          return;
        }

        if(mode!=='forge') return;
        const {x,y} = getPointerPos(e);

        if(oreDrag.on){
          oreDrag.on = false;
          let droppedSlot = -1;
          for(let i=0;i<swordSlots.length;i++){
            if(pointInRect(x,y,swordSlots[i])){ droppedSlot = i; break; }
          }
          if(droppedSlot === targetSlot){
            const s = swordSlots[targetSlot];
            ore.x = s.x + s.w/2;
            ore.y = s.y + s.h/2;
            forgeBurst(ore.x, ore.y, 14);
            if (audioCtx && audioCtx.state === 'running') playAnvilHit(0.9);
            forgeStartCountdown(performance.now());
          } else {
            forgeBurst(x,y,12);
            lose('forge_wrong_slot');
          }
          return;
        }
        if(fan.dragging){ fan.dragging = false; return; }
      }, {passive:true});

      function handleForestKey(key, now){
        if(!running || paused || lost) return;
        if(mode!=='forest') return;
        if(swingResolved) return;

        const need = (swingSide==='left') ? 'a' : 'd';
        if(key===need){
          missesStreak=0;
          updateMissesUI();
          forestResolveCorrect(now);
        } else if(key==='a' || key==='d'){
          missesStreak++;
          updateMissesUI();
          burstWood(W*0.5, H*0.64, 18);
          if(missesStreak>=MAX_MISSES) lose('miss_clicks');
          else lose('wood_wrong');
        }
      }

      function handleForgeKey(key, now){
        if(!running || paused || lost) return;
        if(mode!=='forge') return;
        if(forgePhase!=='qte') return;
        if(!qteSeq.length) return;

        const per = Math.max(420, 900/(0.85 + difficulty*0.55));

        if(now > qteKeyDeadline){
          // ‚ùå –±–µ–∑ –¥–æ–ø.–∂–∏–∑–Ω–∏: —Å—Ä–∞–∑—É –ø–æ—Ä–∞–∂–µ–Ω–∏–µ
          lose('forge_timeout');
          return;
        }

        const cur = qteSeq[qteIndex];
        if(!cur) return;

        if(cur.length === 1){
          if(key !== cur){
            lose('forge_wrong_key');
            return;
          }

          qteRepeatPressed = 0;
          qteIndex++;

          if (audioCtx && audioCtx.state === 'running') playAnvilHit(0.80);
          shakePower = 0.8 + clamp01((difficulty-1)/6)*1.8;
          shakeUntil = now + 120;

          if(qteIndex >= qteSeq.length){ forgeStartFan(now); return; }
          qteKeyDeadline = now + per;
          return;
        }

        const kcur = cur[0];

        if(key !== kcur){
          lose('forge_wrong_key');
          return;
        }

        qteRepeatPressed++;

        if (audioCtx && audioCtx.state === 'running') playAnvilHit(0.65);
        shakePower = 0.9 + clamp01((difficulty-1)/6)*2.1;
        shakeUntil = now + 140;

        if(qteRepeatPressed >= 2){
          qteRepeatPressed = 0;
          qteIndex++;

          if(qteIndex >= qteSeq.length){ forgeStartFan(now); return; }
          qteKeyDeadline = now + per;
        } else {
          qteKeyDeadline = now + per * 0.85;
        }
      }

      window.addEventListener('pointerdown', async () => {
        await resumeAudio();
        if (musicOn && !musicTimer) startMusic();
      }, { once:true });

      // ---------- Loop ----------
      function frame(now){
        const dt = Math.min(33, now - lastTime);
        lastTime = now;

        drawBackgroundBase();
        fctx.clearRect(0,0,W,H);

        if(running && !paused && !lost){
          if(mode==='mines'){
            spawnTimer += dt;
            if(spawnTimer >= nextSpawn){
              spawnTimer = 0;
              spawnRock();
              scheduleNextSpawn();
            }
            for(let i=rocks.length-1;i>=0;i--){
              const k = drawRock(rocks[i], now);
              if(k>=1){ lose('miss_rock'); break; }
            }
          } else if(mode==='forest'){
            drawForestScene(now);
            const age = now - swingStart;
            if(!swingResolved && age >= swingLife){
              missesStreak++;
              updateMissesUI();
              burstWood(W*0.5, H*0.64, 18);
              if(missesStreak>=MAX_MISSES) lose('miss_clicks');
              else lose('wood_timeout');
            }
          } else if(mode==='forge'){
            if(forgePhase==='countdown'){
              if(now - countdownStart >= COUNTDOWN_MS) forgeStartQTE(now);
            } else if(forgePhase==='qte'){
              if(now > qteKeyDeadline){
                // ‚ùå –±–µ–∑ –¥–æ–ø.–∂–∏–∑–Ω–∏: —Ç–∞–π–º–µ—Ä –≤—ã—à–µ–ª ‚Äî –ø–æ—Ä–∞–∂–µ–Ω–∏–µ
                lose('forge_timeout');
              }
            } else if(forgePhase==='fan'){
              const elapsedTotal = now - fan.spawnedAt;
              if(elapsedTotal > fan.totalLimit){
                if(fan.turns < fan.turnsTarget) lose('forge_fan_fail');
              } else {
                if(fan.turns >= fan.turnsTarget){
                  forgeCompleteOre(now);
                }
              }
              fan.omega *= Math.pow(0.985, dt/16.7);
            }

            // --- Forge SPACE –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä ---
            if(!forgeSpace.nextAt) forgeSpaceSchedule(now);

            const canShowSpace = (forgePhase==='qte' || forgePhase==='fan');
            if(canShowSpace && !forgeSpace.active && now >= forgeSpace.nextAt){
              forgeSpaceSpawn(now);
            }
            if(forgeSpace.active){
              if(now - forgeSpace.born >= forgeSpace.ttl){
                lose('forge_space_missed'); // ‚ùå –Ω–µ —É—Å–ø–µ–ª ‚Äî –ø–æ—Ä–∞–∂–µ–Ω–∏–µ
              }
            }

            drawForgeScene(now);
          } else if(mode==='herbs'){
            if(herbPointerDown){
              if(now - herbDownAt > HERB_HOLD_LIMIT_MS){
                lose('herb_hold');
              }
            }

            herbSpawnTimer += dt;
            if(herbSpawnTimer >= herbNextSpawn){
              herbSpawnTimer = 0;
              spawnHerb(now);
              herbScheduleNext();
            }

            for(let i=herbs.length-1;i>=0;i--){
              const hb = herbs[i];
              const info = drawHerb(hb, now);
              if(info.k >= 1){
                lose('herb_missed');
                break;
              }
            }

            drawStroke();
            updateSnowOverlay(now);
          } else if(mode==='herbs_fire'){
            fireUpdate(now, dt);
            if(!lost) drawFireScene(now);
          }
        } else {
          if(mode==='forest') drawForestScene(now);
          if(mode==='forge') drawForgeScene(now);
          if(mode==='mines') for(const r of rocks) drawRock(r, now);
          if(mode==='herbs'){
            for(const hb of herbs) drawHerb(hb, now);
            drawStroke();
            updateSnowOverlay(now);
          }
          if(mode==='herbs_fire') drawFireScene(now);
        }

        updateAndDrawParticles(now, dt);
        requestAnimationFrame(frame);
      }

      // ---------- Start actions ----------
      function startMine(level){
        if(level!==1){ showToast(toastMines,'–≠—Ç–æ—Ç —É—Ä–æ–≤–µ–Ω—å –ø–æ–∫–∞ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω ‚ùÑÔ∏è'); return; }
        mode='mines';
        currentJobName='–®–∞—Ö—Ç—ã';
        currentLocationName='–õ–µ–¥—è–Ω—ã–µ —à–∞—Ö—Ç—ã –Ω–æ—Ä—Ç–ª–µ–Ω–¥–∞';
        footerHint.textContent='–®–∞—Ö—Ç—ã: –∫–ª–∏–∫–∞–π –ø–æ –∫–∞–º–Ω—è–º. –ü—Ä–æ–º–∞—Ö–∏ –ø–æ–¥—Ä—è–¥ = –ø–æ—Ä–∞–∂–µ–Ω–∏–µ ‚ùÑÔ∏è';

        resetCommon();
        rocks=[];
        spawnTimer=0;
        nextSpawn=900;
        scheduleNextSpawn();
      }

      function startForest(level){
        if(level!==1){ showToast(toastForest,'–≠—Ç–æ—Ç –º–∞—Ä—à—Ä—É—Ç –ø–æ–∫–∞ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω üå≤'); return; }
        mode='forest';
        currentJobName='–õ–µ—Å–æ–ø–∏–ª–∫–∞';
        currentLocationName='–õ–µ—Å–æ–ø–∏–ª–∫–∞ –ù–æ—Ä—Ç–ª–µ–Ω–¥–∞';
        footerHint.textContent='–õ–µ—Å–æ–ø–∏–ª–∫–∞: —Å–ª–µ–≤–∞ A, —Å–ø—Ä–∞–≤–∞ D ‚Äî –±–µ–π –±—ã—Å—Ç—Ä–æ üå≤';

        resetCommon();
        forestUpdateTiming();
        forestNextSwing(performance.now());
      }

      function startForgeBasic(){
        mode='forge';
        currentJobName='–ö—É–∑–Ω–∏—Ü–∞';
        currentLocationName='–ö–æ–≤–∞—Ç—å –±–∞–∑–æ–≤–æ–µ –æ—Ä—É–∂–∏–µ';
        footerHint.textContent='–ö—É–∑–Ω–∏—Ü–∞: —Ä—É–¥–∞ ‚Üí W/A/S/D (–∏–Ω–æ–≥–¥–∞ D D) ‚Üí –≤–µ–Ω—Ç–∏–ª—è—Ç–æ—Ä 15 –æ–±–æ—Ä–æ—Ç–æ–≤ –∑–∞ 3—Å üî•';

        resetCommon();
        forgePhase='idle';
        ore=null;
        forgeResetRound();

        // ‚úÖ —Å–±—Ä–æ—Å –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–∞ SPACE
        forgeSpaceReset(performance.now());

        if (musicOn && audioCtx && audioCtx.state === 'running') startMusic();
      }

      function startHerbsFrost(){
        mode='herbs';
        currentJobName='–°–±–æ—Ä —Ç—Ä–∞–≤';
        currentLocationName='–ú–æ—Ä–æ–∑–Ω–∞—è —Ç—Ä–∞–≤–∞';
        footerHint.textContent='–°–±–æ—Ä —Ç—Ä–∞–≤: —Ä–µ–∂—å —Å –∑–∞–∂–∞—Ç–æ–π –∫–Ω–æ–ø–∫–æ–π, –Ω–æ –Ω–µ –¥–µ—Ä–∂–∏ —Å–ª–∏—à–∫–æ–º –¥–æ–ª–≥–æ. –ñ–º–∏ –ü–†–û–ë–ï–õ –æ—Ç —Å–Ω–µ–≥–∞!';

        resetCommon();
        herbs=[];
        herbSpawnTimer=0;
        herbNextSpawn=800;
        herbScheduleNext();
        herbPointerDown=false;
        stroke.length=0;
        lastSpaceAt = performance.now();
        snowWhite = 0;

        if (musicOn && audioCtx && audioCtx.state === 'running') startMusic();
      }

      function startHerbsFire(){
        mode='herbs_fire';
        currentJobName='–°–±–æ—Ä —Ç—Ä–∞–≤';
        currentLocationName='–û–≥–Ω–µ–Ω–Ω—ã–π –∫—É—Å—Ç';
        footerHint.textContent='–û–≥–Ω–µ–Ω–Ω—ã–π –∫—É—Å—Ç: –∫–ª–∏–∫–∞–π —è–≥–æ–¥—ã ‚Üí –ª–æ–≤–∏ –∫–æ—Ä–∑–∏–Ω–æ–π (–º—ã—à–∫–æ–π/–ø–∞–ª—å—Ü–µ–º –∏–ª–∏ A/D). –í—Ä–µ–º—è –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–æ!';

        resetCommon();
        fireBerryCount = 3;
        fireRoundNumber = 0;
        fireCaughtThisRound = 0;
        basket.x = W*0.5;
        fireStartRound(performance.now());

        if (musicOn && audioCtx && audioCtx.state === 'running') startMusic();
      }

      // ---------- UI wiring ----------
      goMines.addEventListener('click', showMinesMenu);
      goForest.addEventListener('click', showForestMenu);
      goForge.addEventListener('click', showForgePass);
      goHerbs.addEventListener('click', showHerbsMenu);

      backToMainFromMines.addEventListener('click', showMainMenu);
      backToMainFromForest.addEventListener('click', showMainMenu);
      backToMainFromForgePass.addEventListener('click', showMainMenu);
      backToMainFromForgeMenu.addEventListener('click', showMainMenu);
      backToMainFromHerbsMenu.addEventListener('click', showMainMenu);

      howBtn.addEventListener('click', ()=>{
        hideAllPanels();
        overlay.classList.remove('hidden');
        howPanel.classList.remove('hidden');
      });
      backBtn.addEventListener('click', showMainMenu);

      mine1.addEventListener('click', ()=> startMine(1));
      mine2.addEventListener('click', ()=> {
       window.location.href = 'deep_mines_northland.html';
      });

      mine3.addEventListener('click', ()=> showToast(toastMines,'–≠—Ç–æ—Ç —É—Ä–æ–≤–µ–Ω—å –ø–æ–∫–∞ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω ‚ùÑÔ∏è'));
      mine4.addEventListener('click', ()=> showToast(toastMines,'–≠—Ç–æ—Ç —É—Ä–æ–≤–µ–Ω—å –ø–æ–∫–∞ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω ‚ùÑÔ∏è'));
      mine5.addEventListener('click', ()=> showToast(toastMines,'–≠—Ç–æ—Ç —É—Ä–æ–≤–µ–Ω—å –ø–æ–∫–∞ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω ‚ùÑÔ∏è'));

      forest1.addEventListener('click', ()=> startForest(1));
      forest2.addEventListener('click', ()=> showToast(toastForest,'–≠—Ç–æ—Ç –º–∞—Ä—à—Ä—É—Ç –ø–æ–∫–∞ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω üå≤'));
      forest3.addEventListener('click', ()=> showToast(toastForest,'–≠—Ç–æ—Ç –º–∞—Ä—à—Ä—É—Ç –ø–æ–∫–∞ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω üå≤'));

      forgeEnterBtn.addEventListener('click', ()=>{
        const pass = (forgePass.value || '').trim();
        if(pass === '3535') showForgeMenu();
        else showToast(toastForgePass, '–ù–µ–≤–µ—Ä–Ω—ã–π –ø–∞—Ä–æ–ª—å üî•');
      });
      forgePass.addEventListener('keydown', (e)=>{ if(e.key === 'Enter') forgeEnterBtn.click(); });

      forgeBasic.addEventListener('click', startForgeBasic);

      herbMode1Btn.addEventListener('click', startHerbsFrost);
      herbMode2Btn.addEventListener('click', startHerbsFire);

      againBtn.addEventListener('click', ()=>{
        if(mode==='forest') startForest(1);
        else if(mode==='forge') startForgeBasic();
        else if(mode==='herbs') startHerbsFrost();
        else if(mode==='herbs_fire') startHerbsFire();
        else startMine(1);
      });
      toMenuBtn.addEventListener('click', showMainMenu);

      pauseBtn.addEventListener('click', ()=> togglePause());
      restartBtn.addEventListener('click', ()=>{
        if(mode==='forest') startForest(1);
        else if(mode==='forge') startForgeBasic();
        else if(mode==='herbs') startHerbsFrost();
        else if(mode==='herbs_fire') startHerbsFire();
        else startMine(1);
      });
      resumeBtn.addEventListener('click', ()=> togglePause(false));
      pauseRestartBtn.addEventListener('click', ()=>{
        if(mode==='forest') startForest(1);
        else if(mode==='forge') startForgeBasic();
        else if(mode==='herbs') startHerbsFrost();
        else if(mode==='herbs_fire') startHerbsFire();
        else startMine(1);
      });

      window.addEventListener('keydown', (e)=>{
        const k = e.key.toLowerCase();
        const now = performance.now();

        if(k==='p') togglePause();
        if(k==='escape') showMainMenu();
        if(k==='r'){
          if(mode==='forest') startForest(1);
          else if(mode==='forge') startForgeBasic();
          else if(mode==='herbs') startHerbsFrost();
          else if(mode==='herbs_fire') startHerbsFire();
          else startMine(1);
        }

        if(k===' ' || k==='spacebar'){
          if(mode==='herbs' && running && !paused && !lost){
            lastSpaceAt = now;
            snowWhite = 0;
            if(audioCtx && audioCtx.state==='running') playHerbSlice(0.45);
          }

          // ‚úÖ Forge: –µ—Å–ª–∏ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä –∞–∫—Ç–∏–≤–µ–Ω ‚Äî –ø—Ä–æ—Å—Ç–æ ‚Äú–ø–æ–≥–∞—Å–∏—Ç—å‚Äù, –±–µ–∑ –±–æ–Ω—É—Å–æ–≤
          if(mode==='forge' && running && !paused && !lost){
            if(forgeSpace.active){
              forgeSpace.active = false;
              forgeSpaceSchedule(now);
            }
          }

          e.preventDefault();
        }

        if(mode==='herbs_fire' && running && !paused && !lost){
          if(k==='a') basket.x -= 28;
          if(k==='d') basket.x += 28;
        }

        handleForestKey(k, now);
        if(['w','a','s','d'].includes(k)) handleForgeKey(k, now);
      }, {passive:false});

      musicBtn.addEventListener('click', async ()=>{
        await resumeAudio();
        musicOn = !musicOn;
        musicBtn.textContent = `–ú—É–∑—ã–∫–∞: ${musicOn ? 'ON' : 'OFF'}`;
        if(musicOn) startMusic();
        else stopMusic();
      });

      sfxBtn.addEventListener('click', async ()=>{
        await resumeAudio();
        sfxOn = !sfxOn;
        sfxBtn.textContent = `–ó–≤—É–∫: ${sfxOn ? 'ON' : 'OFF'}`;
      });

      // ---------- Boot ----------
      resize();
      updateMissesUI();
      showMainMenu();
      requestAnimationFrame(frame);
    })();
  </script>
</body>
</html>
